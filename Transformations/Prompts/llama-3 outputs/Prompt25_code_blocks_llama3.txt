Code Block 1:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i, j, l;
  double temp;

  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);

  // hipKernelLaunch is asynchronous, so we need to synchronize the device
  hipDeviceSynchronize();
}

Code Block 2:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipblasHandle_t handle;
  hipblasCreate(&handle);

  hipblasDgemm(handle, HIPBLAS_OP_N, HIPBLAS_OP_N, m, n, k, &alpha, a, lda, b, ldb, &beta, c, ldc);

  hipblasDestroy(handle);
}

Code Block 3:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 4:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  #pragma omp parallel for private(i, j, l) schedule(static)
  for (int j = 0; j < n; j++) {
    for (int i = 0; i < m; i++) {
      double temp = 0.0;
      for (int l = 0; l < k; l++) {
        temp += a[i * lda + l] * b[l * ldb + j];
      }

Code Block 5:
void gemm_parallel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i, j, l;
  float temp;
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 6:
void gemm_parallel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 7:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 8:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i, j, l;
  double temp;

  hipLaunchKernel(gemm_kernel, dim3(1), dim3(256), 0, 0,
    m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);

  hipDeviceSynchronize();
}

Code Block 9:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i, j, l;
  double temp;

#pragma omp parallel for private(i, j, l, temp) schedule(static)
  for (j = 0; j < n; j++) {
    for (i = 0; i < m; i++) {
      temp = 0.0;
      for (l = 0; l < k; l++) {
        temp += a[i * lda + l] * b[l * ldb + j];
      }

Code Block 10:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

