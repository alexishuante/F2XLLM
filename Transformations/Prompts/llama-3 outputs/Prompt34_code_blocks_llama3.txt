Code Block 1:
void gemv_parallel(int n, float *A, float *x, float *y) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (idx < n) {
    float sum = 0.0;
    for (int j = 0; j < n; j++) {
      sum += A[idx * n + j] * x[j];
    }

Code Block 2:
void gemv_parallel(int n, float *A, float *x, float *y) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
        float sum = 0.0f;
        for (int j = 0; j < n; j++) {
            sum += A[i * n + j] * x[j];
        }

Code Block 3:
void gemv_parallel(int n, float *A, float *x, float *y) {
    int i, j;
    float sum;

    // Initialize CUDA
    cudaError_t err = cudaSetDevice(0);
    if (err != cudaSuccess) {
        printf("cudaSetDevice failed: %s\n", cudaGetErrorString(err));
        exit(1);
    }

Code Block 4:
void gemv_parallel(int n, float *A, float *x, float *y) {
    int i, j;
    float sum;
    int blockSize = 256;
    int numBlocks = (n + blockSize - 1) / blockSize;

    gemv_parallel_kernel<<<numBlocks, blockSize>>>(n, A, x, y);

    cudaDeviceSynchronize();
}

Code Block 5:
void gemv_parallel(int n, float *A, float *x, float *y) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
        float sum = 0.0;
        for (int j = 0; j < n; j++) {
            sum += A[i * n + j] * x[j];
        }

Code Block 6:
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  // Transfer data to device
  float *d_A, *d_x, *d_y;
  cudaMalloc((void **)&d_A, n * n * sizeof(float));
  cudaMalloc((void **)&d_x, n * sizeof(float));
  cudaMalloc((void **)&d_y, n * sizeof(float));
  cudaMemcpy(d_A, A, n * n * sizeof(float), cudaMemcpyHostToDevice);
  cudaMemcpy(d_x, x, n * sizeof(float), cudaMemcpyHostToDevice);

  // Launch kernel
  int blockSize = 256;
  int numBlocks = (n + blockSize - 1) / blockSize;
  gemv_kernel<<<numBlocks, blockSize>>>(n, d_A, d_x, d_y);

  // Transfer result back to host
  cudaMemcpy(y, d_y, n * sizeof(float), cudaMemcpyDeviceToHost);

  // Clean up
  cudaFree(d_A);
  cudaFree(d_x);
  cudaFree(d_y);
}

Code Block 7:
void gemv_parallel(int n, float *A, float *x, float *y) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (idx < n) {
    float sum = 0.0;
    for (int j = 0; j < n; j++) {
      sum += A[idx * n + j] * x[j];
    }

Code Block 8:
void gemv_parallel(const int n, const float *A, const float *x, float *y) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (idx < n) {
    float sum = 0.0f;
    for (int j = 0; j < n; j++) {
      sum += A[idx * n + j] * x[j];
    }

Code Block 9:
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (idx < n) {
    sum = 0.0;
    for (j = 0; j < n; j++) {
      sum += A[idx * n + j] * x[j];
    }

Code Block 10:
void gemv_parallel(const int n, const float *A, const float *x, float *y) {
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (idx < n) {
    float sum = 0.0f;
    for (int j = 0; j < n; j++) {
      sum += A[idx * n + j] * x[j];
    }

