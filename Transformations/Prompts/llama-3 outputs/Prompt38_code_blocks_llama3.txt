Code Block 1:
void jacobi_kernel(float *u, float *unew, int n, int niter) {
  int i = blockIdx.x * blockDim.x + threadIdx.x + 1;
  int j = blockIdx.y * blockDim.y + threadIdx.y + 1;
  int k = blockIdx.z * blockDim.z + threadIdx.z + 1;

  if (i < n - 1 && j < n - 1 && k < n - 1) {
    for (int iter = 0; iter < niter; iter++) {
      unew[i + j * n + k * n * n] = 0.125f * (
        u[(i - 1) + j * n + k * n * n] + u[(i + 1) + j * n + k * n * n] +
        u[i + (j - 1) * n + k * n * n] + u[i + (j + 1) * n + k * n * n] +
        u[i + j * n + (k - 1) * n * n] + u[i + j * n + (k + 1) * n * n] +
        u[i + j * n + k * n * n]
      );
    }

Code Block 2:
void jacobi_kernel(double *u, double *unew) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  int k = blockIdx.z * blockDim.z + threadIdx.z;

  if (i > 1 && i < N - 1 && j > 1 && j < N - 1 && k > 1 && k < N - 1) {
    unew[i * N * N + j * N + k] = 0.125 * (u[(i-1) * N * N + j * N + k] +
                                            u[(i+1) * N * N + j * N + k] +
                                            u[i * N * N + (j-1) * N + k] +
                                            u[i * N * N + (j+1) * N + k] +
                                            u[i * N * N + j * N + (k-1)] +
                                            u[i * N * N + j * N + (k+1)] +
                                            u[i * N * N + j * N + k]);
  }

Code Block 3:
void jacobi_kernel(double *u, double *unew, int n) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  int k = blockIdx.z * blockDim.z + threadIdx.z;

  if (i >= 2 && i < n - 1 && j >= 2 && j < n - 1 && k >= 2 && k < n - 1) {
    unew[i * n * n + j * n + k] = 0.125 * (u[(i - 1) * n * n + j * n + k] +
                                           u[(i + 1) * n * n + j * n + k] +
                                           u[i * n * n + (j - 1) * n + k] +
                                           u[i * n * n + (j + 1) * n + k] +
                                           u[i * n * n + j * n + (k - 1)] +
                                           u[i * n * n + j * n + (k + 1)] +
                                           u[i * n * n + j * n + k]);
  }

Code Block 4:
void jacobi_kernel(double *u, double *unew, int n, int niter) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  int k = blockIdx.z * blockDim.z + threadIdx.z;

  if (i >= 2 && i < n - 1 && j >= 2 && j < n - 1 && k >= 2 && k < n - 1) {
    for (int iter = 0; iter < niter; iter++) {
      unew[i * n * n + j * n + k] = 0.125 * (u[(i - 1) * n * n + j * n + k] +
        u[(i + 1) * n * n + j * n + k] + u[i * n * n + (j - 1) * n + k] +
        u[i * n * n + (j + 1) * n + k] + u[i * n * n + j * n + (k - 1)] +
        u[i * n * n + j * n + (k + 1)] + u[i * n * n + j * n + k]);
    }

Code Block 5:
void jacobi_kernel(real *u, real *unew, int n, int niter) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  int k = blockIdx.z * blockDim.z + threadIdx.z;

  if (i >= 2 && i < n - 1 && j >= 2 && j < n - 1 && k >= 2 && k < n - 1) {
    for (int iter = 1; iter <= niter; iter++) {
      unew[i * n * n + j * n + k] = 0.125 * (u[(i - 1) * n * n + j * n + k] +
                                              u[(i + 1) * n * n + j * n + k] +
                                              u[i * n * n + (j - 1) * n + k] +
                                              u[i * n * n + (j + 1) * n + k] +
                                              u[i * n * n + j * n + (k - 1)] +
                                              u[i * n * n + j * n + (k + 1)] +
                                              u[i * n * n + j * n + k]);
    }

Code Block 6:
void jacobi_kernel(float *u, float *unew, int n, int niter) {
  int i = blockIdx.x * blockDim.x + threadIdx.x + 1;
  int j = blockIdx.y * blockDim.y + threadIdx.y + 1;
  int k = blockIdx.z * blockDim.z + threadIdx.z + 1;

  if (i < n - 1 && j < n - 1 && k < n - 1) {
    for (int iter = 0; iter < niter; iter++) {
      unew[index3D(n, i, j, k)] = 0.125f * (
        u[index3D(n, i - 1, j, k)] + u[index3D(n, i + 1, j, k)] +
        u[index3D(n, i, j - 1, k)] + u[index3D(n, i, j + 1, k)] +
        u[index3D(n, i, j, k - 1)] + u[index3D(n, i, j, k + 1)] +
        u[index3D(n, i, j, k)]
      );
    }

Code Block 7:
void jacobi_parallel(float *u, float *unew, int n, int niter) {
  int i, j, k, iter;
  float *d_u, *d_unew;

  // Allocate device memory
  cudaMalloc((void **)&d_u, n * n * n * sizeof(float));
  cudaMalloc((void **)&d_unew, n * n * n * sizeof(float));

  // Copy data to device
  cudaMemcpy(d_u, u, n * n * n * sizeof(float), cudaMemcpyHostToDevice);
  cudaMemcpy(d_unew, unew, n * n * n * sizeof(float), cudaMemcpyHostToDevice);

  for (iter = 1; iter <= niter; iter++) {
    // Launch kernel
    jacobi_kernel<<<dim3(n - 2, n - 2, n - 2), dim3(1, 1, 1)>>>(d_u, d_unew, n);

    // Copy result back to host
    cudaMemcpy(unew, d_unew, n * n * n * sizeof(float), cudaMemcpyDeviceToHost);

    // Swap pointers
    float *tmp = d_u;
    d_u = d_unew;
    d_unew = tmp;
  }

Code Block 8:
void jacobi_kernel(double *u, double *unew, int n) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  int k = blockIdx.z * blockDim.z + threadIdx.z;

  if (i >= 2 && i < n - 1 && j >= 2 && j < n - 1 && k >= 2 && k < n - 1) {
    unew[i * n * n + j * n + k] = 0.125 * (
      u[(i - 1) * n * n + j * n + k] + u[(i + 1) * n * n + j * n + k] +
      u[i * n * n + (j - 1) * n + k] + u[i * n * n + (j + 1) * n + k] +
      u[i * n * n + j * n + (k - 1)] + u[i * n * n + j * n + (k + 1)] +
      u[i * n * n + j * n + k]);
  }

Code Block 9:
void jacobi_kernel(float *u, float *unew, int n, int niter) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  int k = blockIdx.z * blockDim.z + threadIdx.z;

  if (i >= 2 && i < n - 1 && j >= 2 && j < n - 1 && k >= 2 && k < n - 1) {
    for (int iter = 1; iter <= niter; iter++) {
      unew[i * n * n + j * n + k] = 0.125f * (
        u[(i - 1) * n * n + j * n + k] + u[(i + 1) * n * n + j * n + k] +
        u[i * n * n + (j - 1) * n + k] + u[i * n * n + (j + 1) * n + k] +
        u[i * n * n + j * n + (k - 1)] + u[i * n * n + j * n + (k + 1)] +
        u[i * n * n + j * n + k]
      );
    }

Code Block 10:
void jacobi_kernel(float *u, float *unew, int n) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  int k = blockIdx.z * blockDim.z + threadIdx.z;

  if (i >= 2 && i < n - 1 && j >= 2 && j < n - 1 && k >= 2 && k < n - 1) {
    unew[i * n * n + j * n + k] = 0.125f * (
      u[(i-1) * n * n + j * n + k] + u[(i+1) * n * n + j * n + k] +
      u[i * n * n + (j-1) * n + k] + u[i * n * n + (j+1) * n + k] +
      u[i * n * n + j * n + (k-1)] + u[i * n * n + j * n + (k+1)] +
      u[i * n * n + j * n + k]);
  }

