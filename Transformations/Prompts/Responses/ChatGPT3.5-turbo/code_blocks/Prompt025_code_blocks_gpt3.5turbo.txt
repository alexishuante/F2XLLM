--------------- Code Block 1 ---------------
void gemm_c(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c) {
    hipMallocManaged(&a_gpu, lda * k * sizeof(double));
    hipMallocManaged(&b_gpu, ldb * n * sizeof(double));
    hipMallocManaged(&c_gpu, ldc * n * sizeof(double));

    hipMemcpy(a_gpu, a, lda * k * sizeof(double), hipMemcpyHostToDevice);
    hipMemcpy(b_gpu, b, ldb * n * sizeof(double), hipMemcpyHostToDevice);
    hipMemcpy(c_gpu, c, ldc * n * sizeof(double), hipMemcpyHostToDevice);

    gemm_parallel_hip(m, n, k, alpha, a_gpu, lda, b_gpu, ldb, beta, c_gpu, ldc);

    hipMemcpy(c, c_gpu, ldc * n * sizeof(double), hipMemcpyDeviceToHost);

    hipFree(a_gpu);
    hipFree(b_gpu);
    hipFree(c_gpu);
}

--------------- Code Block 2 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipblasHandle_t handle;
    hipblasCreate(&handle);

    double *d_a, *d_b, *d_c;
    hipMalloc(&d_a, sizeof(double) * m * k);
    hipMalloc(&d_b, sizeof(double) * k * n);
    hipMalloc(&d_c, sizeof(double) * m * n);

    hipMemcpy(d_a, a, sizeof(double) * m * k, hipMemcpyHostToDevice);
    hipMemcpy(d_b, b, sizeof(double) * k * n, hipMemcpyHostToDevice);

    hipblasDgemm(handle, HIPBLAS_OP_N, HIPBLAS_OP_N, m, n, k, &alpha, d_a, lda, d_b, ldb, &beta, d_c, ldc);

    hipMemcpy(c, d_c, sizeof(double) * m * n, hipMemcpyDeviceToHost);

    hipFree(d_a);
    hipFree(d_b);
    hipFree(d_c);

    hipblasDestroy(handle);
}

--------------- Code Block 3 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    hipLaunchKernelGGL([&](int i, int j) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }, dim3(m, n), dim3(1, 1));
}

--------------- Code Block 4 ---------------
__global__ void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;

    if (i < m && j < n) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }
}

--------------- Code Block 5 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipLaunchKernelGGL([&] __device__ (int i, int j, int l, double temp) {
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < m; i++) {
                temp = 0.0;
                for (int l = 0; l < k; l++) {
                    temp += a[i * lda + l] * b[l * ldb + j];
                }
                c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
            }
        }
    }, dim3(1, 1, 1), dim3(m, n, 1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 6 ---------------
__global__ void gemm_kernel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;

    if (i < m && j < n) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }
}

void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    int block_size = 32;
    dim3 grid_size((m + block_size - 1) / block_size, (n + block_size - 1) / block_size, 1);
    dim3 block_dim(block_size, block_size, 1);

    hipLaunchKernelGGL(gemm_kernel, grid_size, block_dim, 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 7 ---------------
__global__ void gemm_kernel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;
    if(i < m && j < n) {
        double temp = 0.0;
        for(int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }
}

void gemm_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    dim3 blockSize(16, 16);
    dim3 gridSize((m + blockSize.x - 1) / blockSize.x, (n + blockSize.y - 1) / blockSize.y);
    
    hipLaunchKernelGGL(gemm_kernel, gridSize, blockSize, 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 8 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipLaunchKernelGGL(kernel_gemm_parallel, dim3(n, m), dim3(1, 1, 1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 9 ---------------
__global__ void kernel_gemm(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i = blockIdx.x * 16 + threadIdx.x;
  int j = blockIdx.y * 16 + threadIdx.y;
  
  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

void gemm_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipLaunchKernelGGL(kernel_gemm, dim3((m + 15) / 16, (n + 15) / 16, 1), dim3(16, 16, 1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 10 ---------------
__global__ void gemm(int m, int n, int k, double alpha, double beta, double *a, int lda, double *b, int ldb, double *c, int ldc) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;

    if(i < m && j < n) {
        double temp = 0.0;
        for(int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l + j * ldb];
        }
        c[i + j * ldc] = alpha * temp + beta * c[i + j * ldc];
    }
}

void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipEvent_t start, stop;
    float milliseconds = 0;

    hipEventCreate(&start);
    hipEventCreate(&stop);

    double *d_a, *d_b, *d_c;
    hipMalloc(&d_a, m * k * sizeof(double));
    hipMalloc(&d_b, k * n * sizeof(double));
    hipMalloc(&d_c, m * n * sizeof(double));

    hipMemcpy(d_a, a, m * k * sizeof(double), hipMemcpyHostToDevice);
    hipMemcpy(d_b, b, k * n * sizeof(double), hipMemcpyHostToDevice);
    hipMemcpy(d_c, c, m * n * sizeof(double), hipMemcpyHostToDevice);

    dim3 blockSize(16, 16);
    dim3 gridSize((m + blockSize.x - 1) / blockSize.x, (n + blockSize.y - 1) / blockSize.y);

    hipEventRecord(start);
    hipLaunchKernelGGL(gemm, gridSize, blockSize, 0, 0, m, n, k, alpha, beta, d_a, lda, d_b, ldb, d_c, ldc);
    hipEventRecord(stop);
    hipEventSynchronize(stop);

    hipMemcpy(c, d_c, m * n * sizeof(double), hipMemcpyDeviceToHost);

    hipFree(d_a);
    hipFree(d_b);
    hipFree(d_c);

    hipEventElapsedTime(&milliseconds, start, stop);
    printf("Kernel execution time: %f ms\n", milliseconds);

    hipEventDestroy(start);
    hipEventDestroy(stop);
}

