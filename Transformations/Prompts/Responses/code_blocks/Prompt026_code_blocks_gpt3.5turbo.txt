Code Block 1:
void gemm_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipblasHandle_t handle;
  hipblasCreate(&handle);

  double *d_a, *d_b, *d_c;
  hipMalloc(&d_a, m * k * sizeof(double));
  hipMalloc(&d_b, k * n * sizeof(double));
  hipMalloc(&d_c, m * n * sizeof(double));

  hipMemcpy(d_a, a, m * k * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(d_b, b, k * n * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(d_c, c, m * n * sizeof(double), hipMemcpyHostToDevice);

  hipblasDgemm(handle, HIPBLAS_OP_N, HIPBLAS_OP_N, m, n, k, &alpha, d_a, lda, d_b, ldb, &beta, d_c, ldc);

  hipMemcpy(c, d_c, m * n * sizeof(double), hipMemcpyDeviceToHost);

  hipFree(d_a);
  hipFree(d_b);
  hipFree(d_c);

  hipblasDestroy(handle);
}

Code Block 2:
extern "C" void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    dim3 blockSize(16, 16);
    dim3 gridSize((m + blockSize.x - 1) / blockSize.x, (n + blockSize.y - 1) / blockSize.y);

    hipLaunchKernelGGL(gemm_kernel, gridSize, blockSize, 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;
    
    if (i < m && j < n) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }
}

Code Block 3:
void gemm_hip(int m, int n, int k, double alpha, double *a_h, int lda, double *b_h, int ldb, double beta, double *c_h, int ldc) {
  double *a_d, *b_d, *c_d;
  hipMalloc(&a_d, sizeof(double) * m * k);
  hipMalloc(&b_d, sizeof(double) * k * n);
  hipMalloc(&c_d, sizeof(double) * m * n);

  hipMemcpy(a_d, a_h, sizeof(double) * m * k, hipMemcpyHostToDevice);
  hipMemcpy(b_d, b_h, sizeof(double) * k * n, hipMemcpyHostToDevice);
  hipMemcpy(c_d, c_h, sizeof(double) * m * n, hipMemcpyHostToDevice);

  dim3 block_dim(16, 16);
  dim3 grid_dim((m + block_dim.x - 1) / block_dim.x, (n + block_dim.y - 1) / block_dim.y);

  hipLaunchKernelGGL(gemm_kernel, grid_dim, block_dim, 0, 0, m, n, k, alpha, a_d, lda, b_d, ldb, beta, c_d, ldc);

  hipMemcpy(c_h, c_d, sizeof(double) * m * n, hipMemcpyDeviceToHost);

  hipFree(a_d);
  hipFree(b_d);
  hipFree(c_d);
}

Code Block 4:
void gemm_hip(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    hipLaunchKernelGGL([=] HIP_KERNEL(i, j) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }, dim3(m, n), dim3(1, 1), 0, NULL, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 5:
void gemm_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipLaunchKernelGGL(gemm_kernel, dim3((m + 31) / 32, (n + 31) / 32), dim3(32, 32), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int row = blockIdx.x * blockDim.x + threadIdx.x;
    int col = blockIdx.y * blockDim.y + threadIdx.y;

    if (row < m && col < n) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[row * lda + l] * b[l * ldb + col];
        }
        c[row * ldc + col] = alpha * temp + beta * c[row * ldc + col];
    }
}

Code Block 6:
void gemm(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc){
    int i, j, l;
    double temp;

    for(j=0; j<n; j++){
        for(i=0; i<m; i++){
            temp = 0.0;
            for(l=0; l<k; l++){
                temp += a[i*lda + l] * b[l*ldb + j];
            }
            c[i*ldc + j] = alpha * temp + beta * c[i*ldc + j];
        }
    }
}

Code Block 7:
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    hipLaunchKernelGGL([=] __device__ (int i, int j) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }, dim3(m, n), dim3(1, 1), 0, NULL, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 8:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipStream_t stream;
    hipStreamCreate(&stream);
    double *d_a, *d_b, *d_c;
    
    hipMalloc(&d_a, sizeof(double) * lda * k);
    hipMemcpy(d_a, a, sizeof(double) * lda * k, hipMemcpyHostToDevice);
    
    hipMalloc(&d_b, sizeof(double) * ldb * n);
    hipMemcpy(d_b, b, sizeof(double) * ldb * n, hipMemcpyHostToDevice);
    
    hipMalloc(&d_c, sizeof(double) * ldc * n);
    hipMemcpy(d_c, c, sizeof(double) * ldc * n, hipMemcpyHostToDevice);
    
    int numBlocksX = (m + 31) / 32;
    int numBlocksY = (n + 31) / 32;
    
    hipLaunchKernelGGL(kernel_gemm, dim3(numBlocksX, numBlocksY), dim3(32, 32), 0, stream, m, n, k, alpha, d_a, lda, d_b, ldb, beta, d_c, ldc);
    
    hipMemcpy(c, d_c, sizeof(double) * ldc * n, hipMemcpyDeviceToHost);
    
    hipFree(d_a);
    hipFree(d_b);
    hipFree(d_c);
    hipStreamDestroy(stream);
}

Code Block 9:
void gemm_hip(int m, int n, int k, double alpha, double* A, int lda, double* B, int ldb, double beta, double* C, int ldc) {
    hipLaunchKernelGGL([&](hipLaunchParm lp) {
        int i = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;
        int j = hipBlockIdx_y * hipBlockDim_y + hipThreadIdx_y;
        
        if (i < m && j < n) {
            double temp = 0.0;
            for (int l = 0; l < k; l++) {
                temp += A[i * lda + l] * B[l * ldb + j];
            }
            C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
        }
    }, dim3((m+15)/16, (n+15)/16), dim3(16, 16), 0, NULL, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
}

Code Block 10:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipLaunchKernelGGL([&](hipLaunchParm lp) {
        int i = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;
        int j = hipBlockIdx_y * hipBlockDim_y + hipThreadIdx_y;

        if (i < m && j < n) {
            double temp = 0.0;
            for (int l = 0; l < k; l++) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }, dim3((m + 31) / 32, (n + 31) / 32), dim3(32, 32), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

