Code Block 1:
void gemm_parallel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i, j, l;
  float temp;
  int blocks = (m + 255) / 256;
  int threads = 256;

  hipLaunchKernel(gemm_kernel, dim3(blocks), dim3(threads), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int tx = threadIdx.x;
  int ty = blockIdx.x * 256 + tx;
  int i, j, l;
  float temp;

  if (ty < m) {
    for (j = 0; j < n; j++) {
      temp = 0.0;
      for (l = 0; l < k; l++) {
        temp += a[ty * lda + l] * b[l * ldb + j];
      }
      c[ty * ldc + j] = alpha * temp + beta * c[ty * ldc + j];
    }
  }
}

Code Block 2:
void gemm_parallel(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  int i, j, l;
  float temp;
  hipLaunchKernel(gemm_kernel, dim3(m, n), dim3(1, 1), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  if (i < m && j < n) {
    temp = 0.0;
    for (l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

Code Block 3:
void gemm_hip(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  if (i < m && j < n) {
    float temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

Code Block 4:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i, j, l;
  double temp;

  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);

  hipDeviceSynchronize();
}

__global__ void gemm_kernel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

Code Block 5:
void gemm_parallel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i, j, l;
  float temp;
  hipLaunchKernel(gemm_kernel, dim3(m, n), dim3(1, 1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  if (i < m && j < n) {
    temp = 0.0;
    for (l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

Code Block 6:
void gemm_parallel(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  int i, j, l;
  float temp;
  hipLaunchKernel(gemm_kernel, dim3(m, n), dim3(1, 1), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  if (i < m && j < n) {
    float temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

Code Block 7:
void gemm_parallel(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  int i, j, l;
  float temp;
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *A, int lda, float *B, int ldb, float beta, float *C, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  if (i < m && j < n) {
    float temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

Code Block 8:
void gemm_hip(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  hipEvent_t start, stop;
  hipEventCreate(&start);
  hipEventCreate(&stop);
  hipEventRecord(start, 0);

  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);

  hipEventRecord(stop, 0);
  hipEventSynchronize(stop);
  float elapsed_time = 0;
  hipEventElapsedTime(&elapsed_time, start, stop);
  printf("GEMM time: %.3f ms\n", elapsed_time);

  hipEventDestroy(start);
  hipEventDestroy(stop);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int tx = threadIdx.x;
  int ty = threadIdx.y;
  int bx = blockIdx.x;
  int by = blockIdx.y;
  int i = ty + by * blockDim.y;
  int j = tx + bx * blockDim.x;

  __shared__ float a_shared[BLOCK_SIZE][BLOCK_SIZE];
  __shared__ float b_shared[BLOCK_SIZE][BLOCK_SIZE];

  float temp = 0;
  int l;
  for (l = 0; l < k; l += BLOCK_SIZE) {
    a_shared[ty][tx] = a[i * lda + l + tx];
    b_shared[ty][tx] = b[l * ldb + j];
    __syncthreads();
    for (int k = 0; k < BLOCK_SIZE; k++) {
      temp += a_shared[ty][k] * b_shared[k][tx];
    }
    __syncthreads();
  }

  c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
}

Code Block 9:
void gemm_parallel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i, j, l;
  float temp;
  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  if (i < m && j < n) {
    float temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

Code Block 10:
void gemm_parallel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i, j, l;
  float temp;

  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

__global__ void gemm_kernel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    float temp = 0.0f;
    for (int l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

