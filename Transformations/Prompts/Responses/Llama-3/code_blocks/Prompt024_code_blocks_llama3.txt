--------------- Code Block 1 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
    int i = blockIdx.x;
    float sum = 0.0;

    if (i < n) {
        for (int j = 0; j < n; j++) {
            sum += A[i * n + j] * x[j];
        }
        y[i] = sum;
    }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
    int i, j;
    float sum;

    hipLaunchKernelGGL((gemv_kernel), dim3(n), dim3(1), 0, 0, n, A, x, y);

    // Synchronize threads
    hipDeviceSynchronize();
}

--------------- Code Block 2 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  if (i < n) {
    float sum = 0.0;
    for (int j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernel(gemv_kernel, dim3(1, 1, 1), dim3(n, 1, 1), 0, 0,
                  n, A, x, y);

}

--------------- Code Block 3 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  float sum = 0.0;

  if (i < n) {
    for (int j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL(
    (void *)gemv_kernel,
    dim3(n, 1, 1),
    dim3(256, 1, 1),
    0, 0,
    n, A, x, y
  );

  hipDeviceSynchronize();
}

--------------- Code Block 4 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL((gemv_kernel), dim3(n), dim3(256), 0, 0, n, A, x, y);

  // Kernel function
  __global__ void gemv_kernel(int n, float *A, float *x, float *y) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
      sum = 0.0;
      for (j = 0; j < n; j++) {
        sum += A[i * n + j] * x[j];
      }
      y[i] = sum;
    }
  }
}

--------------- Code Block 5 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  if (i < n) {
    float sum = 0.0f;
    for (int j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipMemcpy(A, A, n * n * sizeof(float), hipMemcpyDeviceToDevice);
  hipMemcpy(x, x, n * sizeof(float), hipMemcpyDeviceToDevice);

  hipLaunchKernel(gemv_kernel, dim3(n), dim3(256), 0, 0, n, A, x, y);

  hipMemcpy(y, y, n * sizeof(float), hipMemcpyDeviceToHost);
}

--------------- Code Block 6 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  if (i < n) {
    float sum = 0.0f;
    for (int j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL(gemv_kernel, dim3(n), dim3(256), 0, 0, n, A, x, y);

  // Synchronize threads
  hipDeviceSynchronize();
}

--------------- Code Block 7 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;
  #pragma hip parallel for
  for (i = 0; i < n; i++) {
    sum = 0.0f;
    for (j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

--------------- Code Block 8 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL((gemv_kernel), dim3(n), dim3(256), 0, 0, n, A, x, y);

  // Kernel function
  __global__ void gemv_kernel(int n, float *A, float *x, float *y) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
      sum = 0.0;
      for (j = 0; j < n; j++) {
        sum += A[i * n + j] * x[j];
      }
      y[i] = sum;
    }
  }
}

--------------- Code Block 9 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  if (i < n) {
    float sum = 0.0;
    for (int j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernel(gemv_kernel, dim3(1, 1, 1), dim3(n, 1, 1), 0, 0,
    n, A, x, y);

}

--------------- Code Block 10 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL(gemv_kernel, dim3(n), dim3(256), 0, 0, n, A, x, y);

  // hipLaunchKernelGGL is a HIP runtime function that launches a kernel on the GPU.
  // The first argument is the kernel function to launch, the second and third arguments
  // specify the grid and block dimensions, and the remaining arguments are passed to the kernel.

  // The kernel function is defined as:
  __global__ void gemv_kernel(int n, float *A, float *x, float *y) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
      sum = 0.0;
      for (j = 0; j < n; j++) {
        sum += A[i * n + j] * x[j];
      }
      y[i] = sum;
    }
  }
}

