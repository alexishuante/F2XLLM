--------------- Code Block 1 ---------------
void gemm_parallel_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  double *a_d, *b_d, *c_d;
  hipMalloc((void **)&a_d, lda * k * sizeof(double));
  hipMalloc((void **)&b_d, ldb * n * sizeof(double));
  hipMalloc((void **)&c_d, ldc * n * sizeof(double));
  hipMemcpy(a_d, a, lda * k * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(b_d, b, ldb * n * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(c_d, c, ldc * n * sizeof(double), hipMemcpyHostToDevice);
  
  // Call Fortran subroutine
  gemm_parallel_(m, n, k, alpha, a_d, lda, b_d, ldb, beta, c_d, ldc);
  
  hipMemcpy(c, c_d, ldc * n * sizeof(double), hipMemcpyDeviceToHost);
  hipFree(a_d);
  hipFree(b_d);
  hipFree(c_d);
}

--------------- Code Block 2 ---------------
__global__ void gemm_kernel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    float temp = 0.0f;
    for (int l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

void gemm_parallel(int m, int n, int k, float alpha, float *a, int lda, float *b, int ldb, float beta, float *c, int ldc) {
  int i, j, l;
  float temp;

  hipLaunchKernel(gemm_kernel, dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 3 ---------------
void gemm_parallel_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  double *a_d, *b_d, *c_d;
  hipMalloc((void **)&a_d, lda * k * sizeof(double));
  hipMalloc((void **)&b_d, ldb * n * sizeof(double));
  hipMalloc((void **)&c_d, ldc * n * sizeof(double));

  hipMemcpy(a_d, a, lda * k * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(b_d, b, ldb * n * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(c_d, c, ldc * n * sizeof(double), hipMemcpyHostToDevice);

  // Call Fortran subroutine
  gemm_parallel(m, n, k, alpha, a_d, lda, b_d, ldb, beta, c_d, ldc);

  hipMemcpy(c, c_d, ldc * n * sizeof(double), hipMemcpyDeviceToHost);

  hipFree(a_d);
  hipFree(b_d);
  hipFree(c_d);
}

--------------- Code Block 4 ---------------
--------------- Code Block 5 ---------------
void gemm_parallel_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipMemcpyToSymbol(a, a, m * k * sizeof(double));
  hipMemcpyToSymbol(b, b, k * n * sizeof(double));
  hipMemcpyToSymbol(c, c, m * n * sizeof(double));

  #pragma omp target teams distribute parallel for collapse(2) map(tofrom:c) thread_limit(256)
  for (int j = 1; j <= n; j++) {
    for (int i = 1; i <= m; i++) {
      double temp = 0.0;
      #pragma omp for reduction(+:temp)
      for (int l = 1; l <= k; l++) {
        temp += a[i + l * lda] * b[l + j * ldb];
      }
      c[i + j * ldc] = alpha * temp + beta * c[i + j * ldc];
    }
  }

  hipMemcpyFromSymbol(c, c, m * n * sizeof(double));
}

--------------- Code Block 6 ---------------
void gemm_parallel_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  hipMemcpyToSymbol(a_d, a, m * k * sizeof(double));
  hipMemcpyToSymbol(b_d, b, k * n * sizeof(double));
  hipMemcpyToSymbol(c_d, c, m * n * sizeof(double));

  int *m_d, *n_d, *k_d, *lda_d, *ldb_d, *ldc_d;
  hipMalloc((void **)&m_d, sizeof(int));
  hipMalloc((void **)&n_d, sizeof(int));
  hipMalloc((void **)&k_d, sizeof(int));
  hipMalloc((void **)&lda_d, sizeof(int));
  hipMalloc((void **)&ldb_d, sizeof(int));
  hipMalloc((void **)&ldc_d, sizeof(int));

  hipMemcpy(m_d, &m, sizeof(int), hipMemcpyHostToDevice);
  hipMemcpy(n_d, &n, sizeof(int), hipMemcpyHostToDevice);
  hipMemcpy(k_d, &k, sizeof(int), hipMemcpyHostToDevice);
  hipMemcpy(lda_d, &lda, sizeof(int), hipMemcpyHostToDevice);
  hipMemcpy(ldb_d, &ldb, sizeof(int), hipMemcpyHostToDevice);
  hipMemcpy(ldc_d, &ldc, sizeof(int), hipMemcpyHostToDevice);

  double *alpha_d, *beta_d;
  hipMalloc((void **)&alpha_d, sizeof(double));
  hipMalloc((void **)&beta_d, sizeof(double));

  hipMemcpy(alpha_d, &alpha, sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(beta_d, &beta, sizeof(double), hipMemcpyHostToDevice);

  hipLaunchKernel(gemm_parallel, dim3(1), dim3(1), 0, 0, m_d, n_d, k_d, alpha_d, a_d, lda_d, b_d, ldb_d, beta_d, c_d, ldc_d);

  hipMemcpy(c, c_d, m * n * sizeof(double), hipMemcpyDeviceToHost);
}

--------------- Code Block 7 ---------------
void gemm_parallel_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int *d_m, *d_n, *d_k, *d_lda, *d_ldb, *d_ldc;
    double *d_alpha, *d_beta;
    hipMalloc((void **)&d_m, sizeof(int));
    hipMalloc((void **)&d_n, sizeof(int));
    hipMalloc((void **)&d_k, sizeof(int));
    hipMalloc((void **)&d_lda, sizeof(int));
    hipMalloc((void **)&d_ldb, sizeof(int));
    hipMalloc((void **)&d_ldc, sizeof(int));
    hipMalloc((void **)&d_alpha, sizeof(double));
    hipMalloc((void **)&d_beta, sizeof(double));
    
    hipMemcpy(d_m, &m, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(d_n, &n, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(d_k, &k, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(d_lda, &lda, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(d_ldb, &ldb, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(d_ldc, &ldc, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(d_alpha, &alpha, sizeof(double), hipMemcpyHostToDevice);
    hipMemcpy(d_beta, &beta, sizeof(double), hipMemcpyHostToDevice);
    
    #pragma omp target teams distribute parallel for
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            gemm_parallel_(&m, &n, &k, &alpha, a, &lda, b, &ldb, &beta, c, &ldc);
        }
    }
    
    hipFree(d_m); hipFree(d_n); hipFree(d_k); hipFree(d_lda); hipFree(d_ldb); hipFree(d_ldc);
    hipFree(d_alpha); hipFree(d_beta);
}

--------------- Code Block 8 ---------------
void gemm_parallel_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  double *a_d, *b_d, *c_d;
  hipMalloc((void **)&a_d, lda * k * sizeof(double));
  hipMalloc((void **)&b_d, ldb * n * sizeof(double));
  hipMalloc((void **)&c_d, ldc * n * sizeof(double));

  hipMemcpy(a_d, a, lda * k * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(b_d, b, ldb * n * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(c_d, c, ldc * n * sizeof(double), hipMemcpyHostToDevice);

  gemm_parallel_(&m, &n, &k, &alpha, a_d, &lda, b_d, &ldb, &beta, c_d, &ldc);

  hipMemcpy(c, c_d, ldc * n * sizeof(double), hipMemcpyDeviceToHost);

  hipFree(a_d);
  hipFree(b_d);
  hipFree(c_d);
}

--------------- Code Block 9 ---------------
void gemm_c(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipMemcpyToSymbol(a_d, a, m * k * sizeof(double));
    hipMemcpyToSymbol(b_d, b, k * n * sizeof(double));
    hipMemcpyToSymbol(c_d, c, m * n * sizeof(double));

    int *m_d, *n_d, *k_d, *lda_d, *ldb_d, *ldc_d;
    hipMalloc((void **)&m_d, sizeof(int));
    hipMalloc((void **)&n_d, sizeof(int));
    hipMalloc((void **)&k_d, sizeof(int));
    hipMalloc((void **)&lda_d, sizeof(int));
    hipMalloc((void **)&ldb_d, sizeof(int));
    hipMalloc((void **)&ldc_d, sizeof(int));

    hipMemcpy(m_d, &m, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(n_d, &n, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(k_d, &k, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(lda_d, &lda, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(ldb_d, &ldb, sizeof(int), hipMemcpyHostToDevice);
    hipMemcpy(ldc_d, &ldc, sizeof(int), hipMemcpyHostToDevice);

    double *alpha_d, *beta_d;
    hipMalloc((void **)&alpha_d, sizeof(double));
    hipMalloc((void **)&beta_d, sizeof(double));

    hipMemcpy(alpha_d, &alpha, sizeof(double), hipMemcpyHostToDevice);
    hipMemcpy(beta_d, &beta, sizeof(double), hipMemcpyHostToDevice);

    hipLaunchKernel(gemm_parallel_, 1, 1, 0, 0, NULL, m_d, n_d, k_d, alpha_d, a_d, lda_d, b_d, ldb_d, beta_d, c_d, ldc_d);

    hipMemcpy(c, c_d, m * n * sizeof(double), hipMemcpyDeviceToHost);
}

--------------- Code Block 10 ---------------
void gemm_parallel_hip(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  double *a_d, *b_d, *c_d;
  hipMalloc((void **)&a_d, lda * k * sizeof(double));
  hipMalloc((void **)&b_d, ldb * n * sizeof(double));
  hipMalloc((void **)&c_d, ldc * n * sizeof(double));
  hipMemcpy(a_d, a, lda * k * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(b_d, b, ldb * n * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(c_d, c, ldc * n * sizeof(double), hipMemcpyHostToDevice);
  #pragma omp target data map(to:a_d[0:lda*k], b_d[0:ldb*n], c_d[0:ldc*n])
  {
    #pragma omp target teams distribute parallel for
    for (int j = 0; j < n; j++) {
      for (int i = 0; i < m; i++) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
          temp += a_d[i + l * lda] * b_d[l + j * ldb];
        }
        c_d[i + j * ldc] = alpha * temp + beta * c_d[i + j * ldc];
      }
    }
  }
  hipMemcpy(c, c_d, ldc * n * sizeof(double), hipMemcpyDeviceToHost);
  hipFree(a_d);
  hipFree(b_d);
  hipFree(c_d);
}

