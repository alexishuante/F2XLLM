--------------- Code Block 1 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  hipblasHandle_t handle;
  hipblasCreate(&handle);

  hipblasDgemm(handle, HIPBLAS_OP_N, HIPBLAS_OP_N, m, n, k, &alpha, A, lda, B, ldb, &beta, C, ldc);

  hipblasDestroy(handle);
}

--------------- Code Block 2 ---------------
__global__ void gemm_kernel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int j = blockIdx.x * blockDim.x + threadIdx.x;
  int i = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

void gemm_parallel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i, j, l;
  double temp;

  hipLaunchKernelGGL((gemm_kernel), dim3(m, n, 1), dim3(1, 1, 1), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

  hipDeviceSynchronize();
}

--------------- Code Block 3 ---------------
__global__ void gemm_kernel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

void gemm_parallel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i, j, l;
  double temp;

  // HIP kernel launch
  hipLaunchKernel(gemm_kernel, dim3(m, n), dim3(1), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

  // Synchronize threads
  hipDeviceSynchronize();
}

--------------- Code Block 4 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i, j, l;
  double temp;

  #pragma hip parallel for collapse(2) private(i, j, l, temp)
  for (j = 0; j < n; j++) {
    for (i = 0; i < m; i++) {
      temp = 0.0;
      for (l = 0; l < k; l++) {
        temp += a[i * lda + l] * b[l * ldb + j];
      }
      c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }
  }
}

--------------- Code Block 5 ---------------
__global__ void gemm_parallel_kernel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int j = blockIdx.x * blockDim.x + threadIdx.x;
  int i = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i, j, l;
  double temp;

  hipLaunchKernelGGL(gemm_parallel_kernel, dim3(m, n), dim3(1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 6 ---------------
__global__ void gemm_kernel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

void gemm_parallel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i, j, l;
  double temp;

  hipLaunchKernelGGL((gemm_kernel), dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

  // Synchronize threads
  hipDeviceSynchronize();
}

--------------- Code Block 7 ---------------
__global__ void gemm_kernel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += a[i * lda + l] * b[l * ldb + j];
    }
    c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
  }
}

void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
  int i, j, l;
  double temp;

  hipLaunchKernelGGL((gemm_kernel), dim3(1), dim3(m, n), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

--------------- Code Block 8 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i, j, l;
  double temp;

  #pragma hip parallel for collapse(2) private(i, j, l, temp)
  for (j = 0; j < n; j++) {
    for (i = 0; i < m; i++) {
      temp = 0.0;
      for (l = 0; l < k; l++) {
        temp += A[i * lda + l] * B[l * ldb + j];
      }
      C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
    }
  }
}

--------------- Code Block 9 ---------------
void gemm_operation(int m, int n, int k, double alpha, double *a, int lda,
                    double *b, int ldb, double beta, double *c, int ldc) {
  // Create HIP device pointers
  double *d_a, *d_b, *d_c;

  // Allocate memory on the device
  hipMalloc((void **)&d_a, lda * k * sizeof(double));
  hipMalloc((void **)&d_b, ldb * n * sizeof(double));
  hipMalloc((void **)&d_c, ldc * n * sizeof(double));

  // Copy data from host to device
  hipMemcpy(d_a, a, lda * k * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(d_b, b, ldb * n * sizeof(double), hipMemcpyHostToDevice);
  hipMemcpy(d_c, c, ldc * n * sizeof(double), hipMemcpyHostToDevice);

  // Call Fortran subroutine
  gemm_parallel_(&m, &n, &k, &alpha, d_a, &lda, d_b, &ldb, &beta, d_c, &ldc);

  // Copy result from device to host
  hipMemcpy(c, d_c, ldc * n * sizeof(double), hipMemcpyDeviceToHost);

  // Free device memory
  hipFree(d_a);
  hipFree(d_b);
  hipFree(d_c);
}

--------------- Code Block 10 ---------------
__global__ void gemm_kernel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;

  if (i < m && j < n) {
    double temp = 0.0;
    for (int l = 0; l < k; l++) {
      temp += A[i * lda + l] * B[l * ldb + j];
    }
    C[i * ldc + j] = alpha * temp + beta * C[i * ldc + j];
  }
}

void gemm_parallel(int m, int n, int k, double alpha, double *A, int lda, double *B, int ldb, double beta, double *C, int ldc) {
  int i, j, l;
  double temp;

  // HIP kernel launch
  hipLaunchKernel((void*)gemm_kernel, dim3(m, n), dim3(1), 0, 0, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);

  // Synchronize threads
  hipDeviceSynchronize();
}

