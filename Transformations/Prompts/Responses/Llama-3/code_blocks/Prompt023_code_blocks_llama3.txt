--------------- Code Block 1 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;
  #pragma hip for private(j, sum)
  for (i = 0; i < n; i++) {
    sum = 0.0f;
    for (j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

--------------- Code Block 2 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL(gemv_kernel, dim3(n), dim3(1), 0, 0, n, A, x, y);

  // gemv_kernel
  __global__ void gemv_kernel(int n, float *A, float *x, float *y) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    if (i < n) {
      sum = 0.0;
      for (j = 0; j < n; j++) {
        sum += A[i * n + j] * x[j];
      }
      y[i] = sum;
    }
  }
}

--------------- Code Block 3 ---------------
void gemv_parallel_hip(int n, float *A, float *x, float *y) {
  float *A_d, *x_d, *y_d;
  hipMalloc((void **)&A_d, n * n * sizeof(float));
  hipMalloc((void **)&x_d, n * sizeof(float));
  hipMalloc((void **)&y_d, n * sizeof(float));
  hipMemcpy(A_d, A, n * n * sizeof(float), hipMemcpyHostToDevice);
  hipMemcpy(x_d, x, n * sizeof(float), hipMemcpyHostToDevice);
  hipMemcpy(y_d, y, n * sizeof(float), hipMemcpyHostToDevice);
  gemv_parallel_(&n, A_d, x_d, y_d);
  hipMemcpy(y, y_d, n * sizeof(float), hipMemcpyDeviceToHost);
  hipFree(A_d);
  hipFree(x_d);
  hipFree(y_d);
}

--------------- Code Block 4 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  if (i < n) {
    float sum = 0.0;
    for (int j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL(gemv_kernel, dim3(n), dim3(256), 0, 0, n, A, x, y);

  hipDeviceSynchronize();
}

--------------- Code Block 5 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  #pragma hip parallel for private(j, sum)
  for (i = 0; i < n; i++) {
    sum = 0.0f;
    for (j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

--------------- Code Block 6 ---------------
void gemv_parallel_hip(int n, float *A, float *x, float *y) {
  float *A_d, *x_d, *y_d;
  hipMalloc((void **)&A_d, n * n * sizeof(float));
  hipMalloc((void **)&x_d, n * sizeof(float));
  hipMalloc((void **)&y_d, n * sizeof(float));
  hipMemcpy(A_d, A, n * n * sizeof(float), hipMemcpyHostToDevice);
  hipMemcpy(x_d, x, n * sizeof(float), hipMemcpyHostToDevice);
  hipMemcpy(y_d, y, n * sizeof(float), hipMemcpyHostToDevice);
  int numThreads = omp_get_max_threads();
  hipMemcpyToSymbol(&numThreads, "OMP_NUM_THREADS", sizeof(int));
  hipLaunchKernel(gemv_parallel_, dim3(1), dim3(n), 0, 0, n, A_d, x_d, y_d);
  hipMemcpy(y, y_d, n * sizeof(float), hipMemcpyDeviceToHost);
  hipFree(A_d); hipFree(x_d); hipFree(y_d);
}

--------------- Code Block 7 ---------------
__global__ void gemv_kernel(int n, float *A, float *x, float *y) {
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  float sum = 0.0f;

  if (i < n) {
    for (int j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }
}

void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipLaunchKernelGGL((gemv_kernel), dim3(n), dim3(1), 0, 0, n, A, x, y);

  // Synchronize threads
  hipDeviceSynchronize();
}

--------------- Code Block 8 ---------------
void gemv_parallel_hip(int n, float *A, float *x, float *y) {
  float *A_d;
  float *x_d;
  float *y_d;
  
  // Allocate memory on the device
  hipMalloc((void **)&A_d, n * n * sizeof(float));
  hipMalloc((void **)&x_d, n * sizeof(float));
  hipMalloc((void **)&y_d, n * sizeof(float));
  
  // Copy data from host to device
  hipMemcpy(A_d, A, n * n * sizeof(float), hipMemcpyHostToDevice);
  hipMemcpy(x_d, x, n * sizeof(float), hipMemcpyHostToDevice);
  
  // Call the Fortran subroutine
  gemv_parallel_(&n, A_d, x_d, y_d);
  
  // Copy result from device to host
  hipMemcpy(y, y_d, n * sizeof(float), hipMemcpyDeviceToHost);
  
  // Free memory on the device
  hipFree(A_d);
  hipFree(x_d);
  hipFree(y_d);
}

--------------- Code Block 9 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipMemcpy(A, d_A, n*n*sizeof(float), hipMemcpyDeviceToHost);
  hipMemcpy(x, d_x, n*sizeof(float), hipMemcpyDeviceToHost);

  #pragma hip for private(j, sum)
  for (i = 0; i < n; i++) {
    sum = 0.0;
    for (j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }

  hipMemcpy(d_y, y, n*sizeof(float), hipMemcpyHostToDevice);
}

--------------- Code Block 10 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
  int i, j;
  float sum;

  hipMemcpy(A, d_A, n * n * sizeof(float), hipMemcpyDeviceToHost);
  hipMemcpy(x, d_x, n * sizeof(float), hipMemcpyDeviceToHost);

  #pragma omp parallel for private(j, sum)
  for (i = 0; i < n; i++) {
    sum = 0.0;
    for (j = 0; j < n; j++) {
      sum += A[i * n + j] * x[j];
    }
    y[i] = sum;
  }

  hipMemcpy(d_y, y, n * sizeof(float), hipMemcpyHostToDevice);
}

