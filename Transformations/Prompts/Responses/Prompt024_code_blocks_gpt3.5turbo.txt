Code Block 1:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i, j, l;
    double temp;
    #pragma acc parallel loop collapse(2) private(i, j, l, temp)
    for (j = 0; j < n; j++) {
        for (i = 0; i < m; i++) {
            temp = 0.0;
            for (l = 0; l < k; l++) {
                temp += a[i*lda + l] * b[l*ldb + j];
            }
            c[i*ldc + j] = alpha * temp + beta * c[i*ldc + j];
        }
    }
}

Code Block 2:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i, j, l;
    double temp;
    #pragma acc parallel loop collapse(2) private(i, j, l, temp)
    for(j = 0; j < n; j++) {
        for(i = 0; i < m; i++) {
            temp = 0.0;
            for(l = 0; l < k; l++) {
                temp += a[i*lda + l] * b[l*ldb + j];
            }
            c[i*ldc + j] = alpha * temp + beta * c[i*ldc + j];
        }
    }
}

Code Block 3:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i, j, l;
    double temp;
    
    #pragma acc parallel loop collapse(2) private(i, j, l, temp)
    for (j = 0; j < n; j++) {
        for (i = 0; i < m; i++) {
            temp = 0.0;
            for (l = 0; l < k; l++) {
                temp += a[i*lda + l] * b[l*ldb + j];
            }
            c[i*ldc + j] = alpha * temp + beta * c[i*ldc + j];
        }
    }
}

Code Block 4:
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            double temp = 0.0;
            for (int l = 0; l < k; l++) {
                temp += a[i*lda + l] * b[l*ldb + j];
            }
            c[i*ldc + j] = alpha * temp + beta * c[i*ldc + j];
        }
    }
}

__global__ void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;

    if (i < m && j < n) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i*lda + l] * b[l*ldb + j];
        }
        c[i*ldc + j] = alpha * temp + beta * c[i*ldc + j];
    }
}

Code Block 5:
void gemm(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int blockSize = 256;
    dim3 gridSize((m + blockSize - 1) / blockSize, (n + blockSize - 1) / blockSize);
    hipLaunchKernelGGL(gemm_parallel, gridSize, blockSize, 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

__global__ void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int j = blockIdx.y * blockDim.y + threadIdx.y;

    if(i < m && j < n) {
        double temp = 0.0;
        for(int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }
}

Code Block 6:
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    int i, j, l;
    double temp;
    
    hipLaunchKernelGGL(
        [=] HIP_KERNEL() {
            for (j = 0; j < n; j++) {
                for (i = 0; i < m; i++) {
                    temp = 0.0;
                    for (l = 0; l < k; l++) {
                        temp += a[i + l * lda] * b[l + j * ldb];
                    }
                    c[i + j * ldc] = alpha * temp + beta * c[i + j * ldc];
                }
            }
        },
        dim3((m + 15) / 16, (n + 15) / 16),
        dim3(16, 16),
        0,
        NULL
    );
}

Code Block 7:
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    hipLaunchKernelGGL([&](int i, int j) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }, dim3(m, n), dim3(1, 1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 8:
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    hipLaunchKernelGGL([=] HIP_KERNEL
    (int i, int j) {
        double temp = 0.0;
        for(int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l * ldb + j];
        }
        c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
    }, dim3(m, n), dim3(1, 1, 1), 0, NULL, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

Code Block 9:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipLaunchKernelGGL([=] __global__ void (double *a, double *b, double *c) {
        int i = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;
        int j = hipBlockIdx_y * hipBlockDim_y + hipThreadIdx_y;
        double temp = 0.0;

        if (i < m && j < n) {
            for (int l = 0; l < k; l++) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }, dim3((m + 15) / 16, (n + 15) / 16), dim3(16, 16), 0, 0, a, b, c);
}

Code Block 10:
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    hipLaunchKernelGGL([&](int i, int j) {
        double temp = 0.0;
        for (int l = 0; l < k; l++) {
            temp += a[i * lda + l] * b[l + j * ldb];
        }
        c[i + j * ldc] = alpha * temp + beta * c[i + j * ldc];
    }, dim3(m, n), dim3(1, 1), 0, 0, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc);
}

