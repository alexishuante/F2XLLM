--------------- Code Block 1 ---------------
void jacobi_parallel(double* u, double* unew, int n, int niter) {
    int i, j, k, iter;

    #pragma omp parallel private(i, j, k, iter)
    for (iter = 0; iter < niter; ++iter) {
        #pragma omp for collapse(3)
        for (k = 1; k < n - 1; ++k) {
            for (j = 1; j < n - 1; ++j) {
                for (i = 1; i < n - 1; ++i) {
                    // Note: `unew` is indexed in 3D, which needs a linear index calculation in C
                    int index = i + n * (j + n * k);
                    int index_i1 = (i-1) + n * (j + n * k);
                    int index_i2 = (i+1) + n * (j + n * k);
                    int index_j1 = i + n * ((j-1) + n * k);
                    int index_j2 = i + n * ((j+1) + n * k);
                    int index_k1 = i + n * (j + n * (k-1));
                    int index_k2 = i + n * (j + n * (k+1));
                    unew[index] = 0.125 * (u[index_i1] + u[index_i2] +
                                           u[index_j1] + u[index_j2] +
                                           u[index_k1] + u[index_k2] +
                                           u[index]);
                }
            }
        }

        #pragma omp single
        {
            // Update u to be unew
            for (k = 0; k < n; ++k) {
                for (j = 0; j < n; ++j) {
                    for (i = 0; i < n; ++i) {
                        int index = i + n * (j + n * k);
                        u[index] = unew[index];
                    }
                }
            }
        }
    }
}

--------------- Code Block 2 ---------------
void jacobi_parallel(double ***u, double ***unew, int n, int niter) {
    int i, j, k, iter;

    for (iter = 0; iter < niter; ++iter) {
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 1; k < n - 1; ++k) {
            for (j = 1; j < n - 1; ++j) {
                for (i = 1; i < n - 1; ++i) {
                    unew[i][j][k] = 0.125 * (u[i-1][j][k] + u[i+1][j][k] +
                                             u[i][j-1][k] + u[i][j+1][k] +
                                             u[i][j][k-1] + u[i][j][k+1] +
                                             u[i][j][k]);
                }
            }
        }
        
        // Copy unew to u
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 0; k < n; ++k) {
            for (j = 0; j < n; ++j) {
                for (i = 0; i < n; ++i) {
                    u[i][j][k] = unew[i][j][k];
                }
            }
        }
    }
}

--------------- Code Block 3 ---------------
void jacobi_parallel(double ***u, double ***unew, int n, int niter) {
    int i, j, k, iter;

    #pragma omp parallel private(i, j, k)
    {
        for (iter = 0; iter < niter; iter++) {
            #pragma omp for collapse(3)
            for (k = 1; k < n - 1; k++) {
                for (j = 1; j < n - 1; j++) {
                    for (i = 1; i < n - 1; i++) {
                        unew[i][j][k] = 0.125 * (u[i-1][j][k] + u[i+1][j][k] +
                                                 u[i][j-1][k] + u[i][j+1][k] +
                                                 u[i][j][k-1] + u[i][j][k+1] +
                                                 u[i][j][k]);
                    }
                }
            }
            #pragma omp single
            {
                // Update the original array `u` with new values from `unew`
                for (k = 1; k < n - 1; k++) {
                    for (j = 1; j < n - 1; j++) {
                        for (i = 1; i < n - 1; i++) {
                            u[i][j][k] = unew[i][j][k];
                        }
                    }
                }
            }
        }
    }
}

--------------- Code Block 4 ---------------
void jacobi_parallel(double*** u, double*** unew, int n, int niter) {
    int i, j, k, iter;

    for (iter = 0; iter < niter; iter++) {
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 1; k < n - 1; k++) {
            for (j = 1; j < n - 1; j++) {
                for (i = 1; i < n - 1; i++) {
                    unew[i][j][k] = 0.125 * (u[i-1][j][k] + u[i+1][j][k] + 
                                             u[i][j-1][k] + u[i][j+1][k] + 
                                             u[i][j][k-1] + u[i][j][k+1] + 
                                             u[i][j][k]);
                }
            }
        }

        // Copy back to u
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 0; k < n; k++) {
            for (j = 0; j < n; j++) {
                for (i = 0; i < n; i++) {
                    u[i][j][k] = unew[i][j][k];
                }
            }
        }
    }
}

--------------- Code Block 5 ---------------
void jacobi_parallel(double* u, double* unew, int n, int niter) {
    int iter, i, j, k;

    #pragma omp parallel default(none) shared(u, unew, n, niter) private(iter, i, j, k)
    {
        for (iter = 0; iter < niter; iter++) {
            #pragma omp for collapse(3)
            for (k = 1; k < n - 1; k++) {
                for (j = 1; j < n - 1; j++) {
                    for (i = 1; i < n - 1; i++) {
                        unew[(i * n * n) + (j * n) + k] = 0.125 * (
                            u[((i-1) * n * n) + (j * n) + k] +
                            u[((i+1) * n * n) + (j * n) + k] +
                            u[(i * n * n) + ((j-1) * n) + k] +
                            u[(i * n * n) + ((j+1) * n) + k] +
                            u[(i * n) + (j * n) + (k-1)] +
                            u[(i * n * n) + (j * n) + (k+1)] +
                            u[(i * n * n) + (j * n) + k]
                        );
                    }
                }
            }

            // Synchronize threads before updating u
            #pragma omp barrier

            // Copy unew to u in parallel
            #pragma omp for collapse(3)
            for (k = 1; k < n - 1; k++) {
                for (j = 1; j < n - 1; j++) {
                    for (i = 1; i < n - 1; i++) {
                        u[(i * n * n) + (j * n) + k] = unew[(i * n * n) + (j * n) + k];
                    }
                }
            }

            // Ensure all threads have completed the copy before next iteration
            #pragma omp barrier
        }
    }
}

--------------- Code Block 6 ---------------
void jacobi_parallel(double ***u, double ***unew, int n, int niter) {
    int i, j, k, iter;

    // Parallelize the outer loop
    for (iter = 0; iter < niter; iter++) {
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 1; k < n - 1; k++) {
            for (j = 1; j < n - 1; j++) {
                for (i = 1; i < n - 1; i++) {
                    unew[i][j][k] = 0.125 * (
                        u[i-1][j][k] + u[i+1][j][k] + 
                        u[i][j-1][k] + u[i][j+1][k] + 
                        u[i][j][k-1] + u[i][j][k+1] + 
                        u[i][j][k]
                    );
                }
            }
        }

        // Update u with the new values from unew
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 0; k < n; k++) {
            for (j = 0; j < n; j++) {
                for (i = 0; i < n; i++) {
                    u[i][j][k] = unew[i][j][k];
                }
            }
        }
    }
}

--------------- Code Block 7 ---------------
void jacobi_parallel(double*** u, double*** unew, int n, int niter) {
    int i, j, k, iter;

    for (iter = 1; iter <= niter; iter++) {
        #pragma omp parallel for collapse(3) private(i, j, k) shared(u, unew)
        for (k = 1; k < n - 1; k++) {
            for (j = 1; j < n - 1; j++) {
                for (i = 1; i < n - 1; i++) {
                    unew[i][j][k] = 0.125 * (u[i-1][j][k] + u[i+1][j][k] +
                                             u[i][j-1][k] + u[i][j+1][k] +
                                             u[i][j][k-1] + u[i][j][k+1] +
                                             u[i][j][k]);
                }
            }
        }
        
        // Copy unew to u
        #pragma omp parallel for collapse(3) private(i, j, k) shared(u, unew)
        for (k = 0; k < n; k++) {
            for (j = 0; j < n; j++) {
                for (i = 0; i < n; i++) {
                    u[i][j][k] = unew[i][j][k];
                }
            }
        }
    }
}

--------------- Code Block 8 ---------------
void jacobi_parallel(double ***u, double ***unew, int n, int niter) {
    int i, j, k, iter;

    // Perform niter iterations
    for (iter = 1; iter <= niter; iter++) {
        // Parallelize the loops using OpenMP
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 1; k < n - 1; k++) {
            for (j = 1; j < n - 1; j++) {
                for (i = 1; i < n - 1; i++) {
                    unew[i][j][k] = 0.125 * (u[i-1][j][k] + u[i+1][j][k] +
                                              u[i][j-1][k] + u[i][j+1][k] + 
                                              u[i][j][k-1] + u[i][j][k+1] + 
                                              u[i][j][k]);
                }
            }
        }

        // Copy unew to u
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 0; k < n; k++) {
            for (j = 0; j < n; j++) {
                for (i = 0; i < n; i++) {
                    u[i][j][k] = unew[i][j][k];
                }
            }
        }
    }
}

--------------- Code Block 9 ---------------
void jacobi_parallel(double ***u, double ***unew, int n, int niter) {
    int i, j, k, iter;

    for (iter = 1; iter <= niter; iter++) {
        // Parallelizing the 3 nested loops using OpenMP
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 1; k < n - 1; k++) {
            for (j = 1; j < n - 1; j++) {
                for (i = 1; i < n - 1; i++) {
                    unew[i][j][k] = 0.125 * (u[i-1][j][k] + u[i+1][j][k] +
                                             u[i][j-1][k] + u[i][j+1][k] +
                                             u[i][j][k-1] + u[i][j][k+1] +
                                             u[i][j][k]);
                }
            }
        }
        
        // Update u with the new values in unew
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 0; k < n; k++) {
            for (j = 0; j < n; j++) {
                for (i = 0; i < n; i++) {
                    u[i][j][k] = unew[i][j][k];
                }
            }
        }
    }
}

--------------- Code Block 10 ---------------
void jacobi_parallel(int n, int niter, double u[n][n][n], double unew[n][n][n]) {
    int i, j, k, iter;

    for (iter = 1; iter <= niter; iter++) {
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 1; k < n - 1; k++) {
            for (j = 1; j < n - 1; j++) {
                for (i = 1; i < n - 1; i++) {
                    unew[i][j][k] = 0.125 * (u[i-1][j][k] + u[i+1][j][k] +
                                             u[i][j-1][k] + u[i][j+1][k] +
                                             u[i][j][k-1] + u[i][j][k+1] +
                                             u[i][j][k]);
                }
            }
        }

        // Copy unew to u
        #pragma omp parallel for collapse(3) private(i, j, k)
        for (k = 0; k < n; k++) {
            for (j = 0; j < n; j++) {
                for (i = 0; i < n; i++) {
                    u[i][j][k] = unew[i][j][k];
                }
            }
        }
    }
}

