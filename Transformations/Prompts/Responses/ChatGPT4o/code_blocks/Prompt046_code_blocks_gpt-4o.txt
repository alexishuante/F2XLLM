--------------- Code Block 1 ---------------
void gemm_parallel(int m, int n, int k, 
                   typename ViewType::value_type alpha, 
                   const ViewType& a, int lda, 
                   const ViewType& b, int ldb, 
                   typename ViewType::value_type beta, 
                   ViewType& c, int ldc) {
  
  using value_type = typename ViewType::value_type;
  Kokkos::parallel_for(
    "GEMM", 
    Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}), 
    KOKKOS_LAMBDA(const int i, const int j) {
      value_type temp = 0.0;
      for (int l = 0; l < k; ++l) {
        temp += a(i, l) * b(l, j);
      }
      c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 2 ---------------
void gemm_parallel(int m, int n, int k, double alpha, const Kokkos::View<double**>& a, int lda, 
                   const Kokkos::View<double**>& b, int ldb, double beta, Kokkos::View<double**>& c, int ldc) {

    Kokkos::parallel_for("gemm_parallel", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {n, m}), KOKKOS_LAMBDA(const int j, const int i) {
        double temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }
        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 3 ---------------
void gemm_parallel(int m, int n, int k, double alpha, const Kokkos::View<double**> a, const Kokkos::View<double**> b, double beta, Kokkos::View<double**> c) {
  Kokkos::parallel_for(
    "GEMM", 
    Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}),
    KOKKOS_LAMBDA(const int i, const int j) {
      double temp = 0.0;
      for (int l = 0; l < k; l++) {
        temp += a(i, l) * b(l, j);
      }
      c(i, j) = alpha * temp + beta * c(i, j);
    }
  );
}

--------------- Code Block 4 ---------------
void gemm_parallel(int m, int n, int k, Scalar alpha, const Kokkos::View<Scalar**> &a, const Kokkos::View<Scalar**> &b, Scalar beta, Kokkos::View<Scalar**> &c) {
    Kokkos::parallel_for("GEMM", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {n, m}), KOKKOS_LAMBDA(const int j, const int i) {
        Scalar temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }
        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 5 ---------------
void gemm_parallel(int m, int n, int k, double alpha, 
                   const Kokkos::View<double**> &a, int lda, 
                   const Kokkos::View<double**> &b, int ldb, 
                   double beta, Kokkos::View<double**> &c, int ldc) {

  Kokkos::parallel_for("gemm_parallel", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}),
    KOKKOS_LAMBDA(const int i, const int j) {
      double temp = 0.0;
      for (int l = 0; l < k; ++l) {
        temp += a(i, l) * b(l, j);
      }
      c(i, j) = alpha * temp + beta * c(i, j);
  });

}

--------------- Code Block 6 ---------------
void gemm_parallel(int m, int n, int k, double alpha,
                   const Kokkos::View<double**>& a, int lda,
                   const Kokkos::View<double**>& b, int ldb,
                   double beta, Kokkos::View<double**>& c, int ldc) {
  
  // Check if the dimensions match
  assert(lda >= m);
  assert(ldb >= k);
  assert(ldc >= m);
  assert(a.extent(0) == lda);
  assert(b.extent(0) == ldb);
  assert(c.extent(0) == ldc);
  
  Kokkos::parallel_for("gemm_parallel", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}),
    KOKKOS_LAMBDA(int i, int j) {
      double temp = 0.0;
      for (int l = 0; l < k; ++l) {
        temp += a(i, l) * b(l, j);
      }
      c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 7 ---------------
void gemm_parallel(
        const int m, const int n, const int k,
        const Scalar alpha, Kokkos::View<Scalar**> a, const int lda,
        Kokkos::View<Scalar**> b, const int ldb,
        const Scalar beta, Kokkos::View<Scalar**> c, const int ldc) {

    // Define a Kokkos parallel loop
    Kokkos::parallel_for("gemm_parallel", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}), KOKKOS_LAMBDA (const int i, const int j) {
        Scalar temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }
        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 8 ---------------
void gemm_parallel(int m, int n, int k, double alpha, const ViewType &a, const ViewType &b, double beta, ViewType &c) {
    Kokkos::parallel_for("GEMM Loop", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}), KOKKOS_LAMBDA(int i, int j) {
        double temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }
        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 9 ---------------
void gemm_parallel(int m, int n, int k, double alpha, 
                   Kokkos::View<double**> a, int lda, 
                   Kokkos::View<double**> b, int ldb, 
                   double beta, 
                   Kokkos::View<double**> c, int ldc) {
    // Parallelize the outer loops using a Kokkos parallelization pattern
    Kokkos::parallel_for("GEMM", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}), 
        KOKKOS_LAMBDA (int i, int j) {
            double temp = 0.0;
            for (int l = 0; l < k; ++l) {
                temp += a(i, l) * b(l, j);
            }
            c(i, j) = alpha * temp + beta * c(i, j);
        }
    );
}

--------------- Code Block 10 ---------------
void gemm_parallel(int m, int n, int k, Scalar alpha, 
                   const Kokkos::View<Scalar**, Kokkos::LayoutLeft>& A, int lda,
                   const Kokkos::View<Scalar**, Kokkos::LayoutLeft>& B, int ldb,
                   Scalar beta, Kokkos::View<Scalar**, Kokkos::LayoutLeft>& C, int ldc) {

  Kokkos::parallel_for("GEMM", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}),
                       KOKKOS_LAMBDA(int i, int j) {
    Scalar temp = Scalar(0);

    for (int l = 0; l < k; ++l) {
      temp += A(i, l) * B(l, j);
    }

    C(i, j) = alpha * temp + beta * C(i, j);
  });
}

