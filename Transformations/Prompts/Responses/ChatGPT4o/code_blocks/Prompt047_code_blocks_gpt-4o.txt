--------------- Code Block 1 ---------------
void jacobi_parallel(Kokkos::View<double***> u, Kokkos::View<double***> unew, int n, int niter) {
    // Ensure the views are properly resized
    assert(u.extent(0) == n && u.extent(1) == n && u.extent(2) == n);
    assert(unew.extent(0) == n && unew.extent(1) == n && unew.extent(2) == n);

    for (int iter = 0; iter < niter; ++iter) {
        Kokkos::parallel_for("JacobiIteration", Kokkos::MDRangePolicy<Kokkos::Rank<3>>({2, 2, 2}, {n-1, n-1, n-1}), KOKKOS_LAMBDA(const int i, const int j, const int k) {
            unew(i,j,k) = 0.125 * (u(i-1, j, k) + u(i+1, j, k) + u(i, j-1, k) + u(i, j+1, k) + u(i, j, k-1) + u(i, j, k+1) + u(i, j, k));
        });

        // Synchronize to ensure all threads complete calculation before copying
        Kokkos::fence();

        // Copy unew to u
        Kokkos::deep_copy(u, unew);
    }
}

--------------- Code Block 2 ---------------
void jacobi_parallel(ViewType u, ViewType unew, int n, int niter) {
  // Define the policy for parallel loops
  typedef Kokkos::MDRangePolicy<Kokkos::Rank<3>> policy_type;

  for (int iter = 1; iter <= niter; ++iter) {
    Kokkos::parallel_for("JacobiKernel", policy_type({2, 2, 2}, {n - 1, n - 1, n - 1}),
                         KOKKOS_LAMBDA(int k, int j, int i) {
      unew(i, j, k) = 0.125 * (u(i-1, j, k) + u(i+1, j, k) +
                               u(i, j-1, k) + u(i, j+1, k) +
                               u(i, j, k-1) + u(i, j, k+1) +
                               u(i, j, k));
    });

    // Copy data from unew to u for the next iteration
    Kokkos::parallel_for("CopyKernel", policy_type({2, 2, 2}, {n - 1, n - 1, n - 1}),
                         KOKKOS_LAMBDA(int k, int j, int i) {
      u(i, j, k) = unew(i, j, k);
    });

    Kokkos::fence();  // Ensure all operations are completed before the next iteration
  }
}

--------------- Code Block 3 ---------------
void jacobi_parallel(Kokkos::View<double***> u, Kokkos::View<double***> unew, int n, int niter) {
    // Note: Kokkos is designed to work with parallelism implicitly
    // through its execution policies and N-dimensional arrays (Views).
    
    for (int iter = 0; iter < niter; ++iter) {
        Kokkos::parallel_for("Jacobi Update", Kokkos::MDRangePolicy<Kokkos::Rank<3>>({2, 2, 2}, {n-1, n-1, n-1}),
            KOKKOS_LAMBDA(const int i, const int j, const int k) {
                unew(i, j, k) = 0.125 * (u(i-1, j, k) + u(i+1, j, k) +
                                         u(i, j-1, k) + u(i, j+1, k) +
                                         u(i, j, k-1) + u(i, j, k+1) +
                                         u(i, j, k));
        });

        // Use deep_copy to synchronize the views. One could use deep_copy or copy views directly.
        Kokkos::deep_copy(u, unew);
    }
}

--------------- Code Block 4 ---------------
void jacobi_parallel(Kokkos::View<double***> u, Kokkos::View<double***> unew, int n, int niter) {
    // Create a Kokkos execution policy for 3D loop structure
    auto exec_space = Kokkos::DefaultExecutionSpace();

    // 3D range policy for the inner loops
    Kokkos::MDRangePolicy<Kokkos::Rank<3>> policy({2, 2, 2}, {n-1, n-1, n-1});

    for (int iter = 0; iter < niter; ++iter) {
        // Use parallel_for with the range policy
        Kokkos::parallel_for("Jacobi", policy, KOKKOS_LAMBDA(const int i, const int j, const int k) {
            unew(i, j, k) = 0.125 * (u(i - 1, j, k) + u(i + 1, j, k) + u(i, j - 1, k) + 
                                     u(i, j + 1, k) + u(i, j, k - 1) + u(i, j, k + 1) + 
                                     u(i, j, k));
        });
        // Wait for all threads to complete the current iteration
        Kokkos::fence();

        // Swap u and unew after each iteration
        Kokkos::deep_copy(u, unew);
    }
}

--------------- Code Block 5 ---------------
void jacobi_parallel(Kokkos::View<double***> u, Kokkos::View<double***> unew, int n, int niter) {
  // Parallel loop structure similar to the OpenMP parallel region
  for (int iter = 0; iter < niter; ++iter) {
    Kokkos::parallel_for("Jacobi_Kernel", Kokkos::MDRangePolicy<Kokkos::Rank<3>>({2, 2, 2}, {n - 1, n - 1, n - 1}), KOKKOS_LAMBDA(const int i, const int j, const int k) {
      unew(i, j, k) = 0.125 * (u(i-1, j, k) + u(i+1, j, k) +
                               u(i, j-1, k) + u(i, j+1, k) +
                               u(i, j, k-1) + u(i, j, k+1) +
                               u(i, j, k));
    });

    // Synchronize to ensure kernel execution is complete before copying
    Kokkos::fence();

    // Copy unew to u
    Kokkos::parallel_for("Copy_Updated_Values", Kokkos::MDRangePolicy<Kokkos::Rank<3>>({0, 0, 0}, {n, n, n}), KOKKOS_LAMBDA(const int i, const int j, const int k) {
      u(i, j, k) = unew(i, j, k);
    });

    // Again, synchronize to ensure copy completion before next iteration
    Kokkos::fence();
  }
}

--------------- Code Block 6 ---------------
void jacobi_parallel(ViewType u, ViewType unew, int n, int niter) {
  // Temporary variable to facilitate swapping references
  ViewType temp_view("temp_view", n, n, n);

  for (int iter = 0; iter < niter; ++iter) {
    // Parallel loop using Kokkos (using Kokkos::MDRangePolicy for 3D range)
    Kokkos::parallel_for(
      "JacobiKernel",
      Kokkos::MDRangePolicy<Kokkos::Rank<3>>({2, 2, 2}, {n - 1, n - 1, n - 1}),
      KOKKOS_LAMBDA(const int i, const int j, const int k) {
        unew(i, j, k) = 0.125 * (u(i - 1, j, k) + u(i + 1, j, k) + u(i, j - 1, k) +
                                 u(i, j + 1, k) + u(i, j, k - 1) + u(i, j, k + 1) + u(i, j, k));
      }
    );

    // Synchronize to ensure all threads have completed the above computation
    Kokkos::fence();

    // Swap references to avoid copying elements
    temp_view = u;
    u = unew;
    unew = temp_view;
  }
}

--------------- Code Block 7 ---------------
void jacobi_parallel(
    Kokkos::View<double***> u, 
    Kokkos::View<double***> unew, 
    int n, int niter) 
{
    for(int iter = 0; iter < niter; ++iter) {
        
        Kokkos::parallel_for("jacobi_iteration", 
            Kokkos::MDRangePolicy<Kokkos::Rank<3>>({2, 2, 2}, {n-1, n-1, n-1}), 
            KOKKOS_LAMBDA(const int k, const int j, const int i) 
        {
            unew(i, j, k) = 0.125 * (u(i-1, j, k) + u(i+1, j, k) +
                                     u(i, j-1, k) + u(i, j+1, k) +
                                     u(i, j, k-1) + u(i, j, k+1) +
                                     u(i, j, k));
        });

        Kokkos::fence(); // Ensure all threads are done before the update

        Kokkos::deep_copy(u, unew); // Copy unew to u
    }
}

--------------- Code Block 8 ---------------
void jacobi_parallel(ViewType u, ViewType unew, int n, int niter) {
  using policy_type = Kokkos::MDRangePolicy<Kokkos::Rank<3>>;
  // Iterate over each iteration
  for (int iter = 0; iter < niter; ++iter) {
    // Jacobi update step
    Kokkos::parallel_for("Jacobi Update", policy_type({2, 2, 2}, {n-1, n-1, n-1}),
    KOKKOS_LAMBDA (const int i, const int j, const int k) {
      unew(i, j, k) = 0.125 * (u(i-1, j, k) + u(i+1, j, k) +
                               u(i, j-1, k) + u(i, j+1, k) +
                               u(i, j, k-1) + u(i, j, k+1) +
                               u(i, j, k));
    });

    // Copy unew to u
    Kokkos::deep_copy(u, unew);
  }
}

--------------- Code Block 9 ---------------
void jacobi_parallel(double* u, double* unew, int n, int niter, int nthreads) {
  Kokkos::initialize();
  {
    using ViewType = Kokkos::View<double***, Kokkos::LayoutRight, Kokkos::DefaultExecutionSpace>;
    
    ViewType u_view(u, n, n, n);
    ViewType unew_view(unew, n, n, n);
    
    for (int iter = 0; iter < niter; ++iter) {
      Kokkos::parallel_for(
        "Jacobi Update", 
        Kokkos::MDRangePolicy<Kokkos::Rank<3>>({2, 2, 2}, {n-1, n-1, n-1}),
        KOKKOS_LAMBDA(int i, int j, int k) {
          unew_view(i, j, k) = 0.125 * (
            u_view(i-1, j, k) + u_view(i+1, j, k) + 
            u_view(i, j-1, k) + u_view(i, j+1, k) + 
            u_view(i, j, k-1) + u_view(i, j, k+1) + 
            u_view(i, j, k)
          );
        }
      );

      Kokkos::fence();
      
      Kokkos::parallel_for(
        "Copy New to Old", 
        Kokkos::MDRangePolicy<Kokkos::Rank<3>>({0, 0, 0}, {n, n, n}),
        KOKKOS_LAMBDA(int i, int j, int k) {
          u_view(i, j, k) = unew_view(i, j, k);
        }
      );
      
      Kokkos::fence();
    }
  }
  Kokkos::finalize();
}

--------------- Code Block 10 ---------------
void jacobi_parallel(double* u, double* unew, int n, int niter, int nthreads) {
    Kokkos::initialize();

    {
        const int size = n * n * n;
        const int nm1 = n - 1;
        Kokkos::View<double***, Kokkos::LayoutRight> u_view(u, n, n, n);
        Kokkos::View<double***, Kokkos::LayoutRight> unew_view(unew, n, n, n);

        for (int iter = 0; iter < niter; ++iter) {
            Kokkos::parallel_for("JacobiIteration", Kokkos::MDRangePolicy<Kokkos::Rank<3>>({1, 1, 1}, {nm1, nm1, nm1}), KOKKOS_LAMBDA(const int k, const int j, const int i) {
                unew_view(i, j, k) = 0.125 * (u_view(i-1, j, k) + u_view(i+1, j, k) +
                                              u_view(i, j-1, k) + u_view(i, j+1, k) +
                                              u_view(i, j, k-1) + u_view(i, j, k+1) +
                                              u_view(i, j, k));
            });

            // Time to swap or copy u and unew
            Kokkos::deep_copy(u_view, unew_view);
        }
    }

    Kokkos::finalize();
}

