--------------- Code Block 1 ---------------
void gemv_parallel(int n, float **A, float *x, float *y) {
    int i, j;
    float sum;

    #pragma acc parallel loop private(i, j, sum)
    for (i = 0; i < n; i++) {
        sum = 0.0;
        for (j = 0; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 2 ---------------
void gemv_parallel(int n, float A[n][n], float x[n], float y[n]) {
    #pragma acc parallel loop
    for (int i = 0; i < n; i++) {
        float sum = 0.0f;
        for (int j = 0; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 3 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
    int i, j;

    // Parallelize the outer loop with OpenACC
    #pragma acc parallel loop
    for (i = 0; i < n; i++) {
        float sum = 0.0f;

        // Nested loop to perform the dot product operation
        for (j = 0; j < n; j++) {
            sum += A[i * n + j] * x[j];
        }

        y[i] = sum;
    }
}

--------------- Code Block 4 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
    int i, j;
    float sum;

    #pragma acc parallel loop collapse(1) copyin(A[0:n*n], x[0:n]) copyout(y[0:n])
    for (i = 0; i < n; ++i) {
        sum = 0.0;
        for (j = 0; j < n; ++j) {
            sum += A[i * n + j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 5 ---------------
void gemv_parallel(int n, const float A[n][n], const float x[n], float y[n]) {
    int i, j;

    #pragma acc parallel loop
    for (i = 0; i < n; ++i) {
        float sum = 0.0f;
        for (j = 0; j < n; ++j) {
            sum += A[i][j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 6 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
    int i, j;
    
    #pragma acc parallel loop
    for (i = 0; i < n; i++) {
        float sum = 0.0f;
        
        #pragma acc loop reduction(+:sum)
        for (j = 0; j < n; j++) {
            sum += A[i * n + j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 7 ---------------
void gemv_parallel(int n, float A[n][n], float x[n], float y[n]) {
    int i, j;
    float sum;

    #pragma acc parallel loop present(A, x, y)
    for (i = 0; i < n; i++) {
        sum = 0.0f;
        for (j = 0; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 8 ---------------
void gemv_parallel(int n, float *A, float *x, float *y) {
    #pragma acc parallel loop
    for (int i = 0; i < n; i++) {
        float sum = 0.0f;
        for (int j = 0; j < n; j++) {
            sum += A[i * n + j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 9 ---------------
void gemv_parallel(int n, float A[n][n], float x[n], float y[n]) {
    // i and j are loop counter variables; sum is used to accumulate the dot product.
    int i, j;
    float sum;

    #pragma acc parallel loop
    for (i = 0; i < n; i++) {
        sum = 0.0;
        for (j = 0; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        y[i] = sum;
    }
}

--------------- Code Block 10 ---------------
void gemv_parallel(int n, float **A, float *x, float *y) {
    int i, j;
    float sum;

    // OpenACC parallel directive
    #pragma acc parallel loop private(i, j, sum)
    for (i = 0; i < n; i++) {
        sum = 0.0;
        // OpenACC loop directive for the inner loop
        #pragma acc loop reduction(+:sum)
        for (j = 0; j < n; j++) {
            sum += A[i][j] * x[j];
        }
        y[i] = sum;
    }
}

