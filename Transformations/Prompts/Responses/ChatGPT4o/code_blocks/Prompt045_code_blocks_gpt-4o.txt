--------------- Code Block 1 ---------------
void gemm_parallel(int m, int n, int k, double alpha, 
                   const Kokkos::View<double**> &a, int lda, 
                   const Kokkos::View<double**> &b, int ldb, 
                   double beta, 
                   Kokkos::View<double**> &c, int ldc) {
  // Parallel execution using Kokkos
  Kokkos::parallel_for("GEMM", Kokkos::RangePolicy<>(0, n), KOKKOS_LAMBDA(const int j) {
    for (int i = 0; i < m; ++i) {
      double temp = 0.0;
      for (int l = 0; l < k; ++l) {
        temp += a(i, l) * b(l, j);
      }
      c(i, j) = alpha * temp + beta * c(i, j);
    }
  });
}

--------------- Code Block 2 ---------------
void gemm_parallel(int m, int n, int k, 
                   ScalarType alpha, 
                   const Kokkos::View<ScalarType**, Kokkos::LayoutLeft>& A, 
                   const Kokkos::View<ScalarType**, Kokkos::LayoutLeft>& B, 
                   ScalarType beta, 
                   Kokkos::View<ScalarType**, Kokkos::LayoutLeft>& C) {
    Kokkos::parallel_for("GEMM", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {m, n}),
        KOKKOS_LAMBDA(const int i, const int j) {
            ScalarType temp = 0.0;
            for (int l = 0; l < k; ++l) {
                temp += A(i, l) * B(l, j);
            }
            C(i, j) = alpha * temp + beta * C(i, j);
        } 
    );
}

--------------- Code Block 3 ---------------
void gemm_parallel(const int m, const int n, const int k, 
                   const double alpha, const double* a, const int lda, 
                   const double* b, const int ldb, 
                   const double beta, double* c, const int ldc) 
{
  // Wrap the raw pointers into Kokkos Views
  Kokkos::View<const double**> A(a, lda, k);
  Kokkos::View<const double**> B(b, ldb, n);
  Kokkos::View<double**> C(c, ldc, n);

  // Perform the GEMM calculation
  Kokkos::parallel_for("GEMM", Kokkos::TeamPolicy<>(n, Kokkos::AUTO), KOKKOS_LAMBDA(const Kokkos::TeamPolicy<>::member_type& team) {
    const int j = team.league_rank(); // Index for columns of C and B

    Kokkos::parallel_for(Kokkos::TeamThreadRange(team, m), [&] (const int i) {
      double temp = 0.0;

      Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, k), [=] (const int l, double& local_sum) {
        local_sum += A(i, l) * B(l, j);
      }, temp);
      
      // Update C matrix with the computed value
      Kokkos::single(Kokkos::PerThread(team), [&] () {
        C(i, j) = alpha * temp + beta * C(i, j);
      });
    }); 
  });
}

--------------- Code Block 4 ---------------
void gemm_parallel(int m, int n, int k, double alpha, const ViewType& a, const ViewType& b, double beta, ViewType& c) {
    using execution_space = typename ViewType::execution_space;
    using policy = Kokkos::MDRangePolicy<Kokkos::Rank<2>, execution_space>;

    // Parallel region over 2D range [0:m, 0:n]
    Kokkos::parallel_for("gemm_parallel", policy({0, 0}, {m, n}), KOKKOS_LAMBDA(int i, int j) {
        double temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }
        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 5 ---------------
void gemm_parallel(int m, int n, int k, double alpha, ViewTypeA a, ViewTypeB b, double beta, ViewTypeC c) {
    Kokkos::parallel_for("GEMM", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {n, m}), KOKKOS_LAMBDA (const int j, const int i) {
        double temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }
        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 6 ---------------
void gemm_parallel(int m, int n, int k, double alpha, const ViewType& a, const ViewType& b, double beta, ViewType& c) {
  // Parallelizing the outer two loops with Kokkos
  Kokkos::parallel_for("gemm", Kokkos::RangePolicy<>(0, n * m), KOKKOS_LAMBDA(int idx){
    int i = idx % m;
    int j = idx / m;
    double temp = 0.0;
    for (int l = 0; l < k; ++l) {
      temp += a(i, l) * b(l, j);
    }
    c(i, j) = alpha * temp + beta * c(i, j);
  });
}

--------------- Code Block 7 ---------------
void gemm_parallel(const int m, const int n, const int k, const double alpha,
                   const Kokkos::View<double**> a, const int lda,
                   const Kokkos::View<double**> b, const int ldb,
                   const double beta, Kokkos::View<double**> c, const int ldc) {

  // Define the execution policy
  Kokkos::parallel_for("GEMM", Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {n, m}),
    KOKKOS_LAMBDA(const int j, const int i) {
      double temp = 0.0;

      // Compute the dot product of the i-th row of 'a' with the j-th column of 'b'
      for (int l = 0; l < k; ++l) {
        temp += a(i, l) * b(l, j);
      }

      // Scale by alpha, add beta*c
      c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 8 ---------------
void gemm_parallel(int m, int n, int k, value_type alpha, const Kokkos::View<value_type**>& a, int lda, const Kokkos::View<value_type**>& b, int ldb, value_type beta, Kokkos::View<value_type**>& c, int ldc) {
    // Create execution space to be used for parallelization
    Kokkos::parallel_for("GEMM", Kokkos::RangePolicy<>(0, n * m), KOKKOS_LAMBDA(int index) {
        int i = index % m;
        int j = index / m;
        
        value_type temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }

        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 9 ---------------
void gemm_parallel(int m, int n, int k, double alpha, const Kokkos::View<double**> &a, int lda,
                   const Kokkos::View<double**> &b, int ldb, double beta, Kokkos::View<double**> &c, int ldc) {
    Kokkos::parallel_for("GEMM", Kokkos::RangePolicy<Kokkos::OpenMP>(0, n * m), KOKKOS_LAMBDA(int t) {
        int j = t / m; // Gets the column index
        int i = t % m; // Gets the row index

        double temp = 0.0;
        for (int l = 0; l < k; ++l) {
            temp += a(i, l) * b(l, j);
        }
        c(i, j) = alpha * temp + beta * c(i, j);
    });
}

--------------- Code Block 10 ---------------
void gemm_kokkos(int m, int n, int k, double alpha, const double* a, int lda,
                 const double* b, int ldb, double beta, double* c, int ldc) {
  
  using execution_space = Kokkos::DefaultExecutionSpace;
  using range_policy = Kokkos::RangePolicy<execution_space>;

  Kokkos::parallel_for("GEMM", range_policy(0, n*m), KOKKOS_LAMBDA(const int idx) {
    int j = idx / m;
    int i = idx % m;
  
    double temp = 0.0;
    for(int l = 0; l < k; ++l) {
      temp += a[i + l * lda] * b[l + j * ldb];
    }
    c[i + j * ldc] = alpha * temp + beta * c[i + j * ldc];
  });
}

