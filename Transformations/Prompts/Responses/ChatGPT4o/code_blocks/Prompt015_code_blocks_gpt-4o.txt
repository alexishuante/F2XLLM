--------------- Code Block 1 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    
    #pragma acc parallel loop collapse(2) present(a[0:lda*k], b[0:ldb*n], c[0:ldc*n])
    for (int j = 0; j < n; j++) {
        for (int i = 0; i < m; i++) {
            double temp = 0.0;
            for (int l = 0; l < k; l++) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }
}

--------------- Code Block 2 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    #pragma acc parallel loop collapse(2) present(a[0:lda*k], b[0:ldb*n], c[0:ldc*n])
    for (int j = 0; j < n; ++j) {
        for (int i = 0; i < m; ++i) {
            double temp = 0.0;
            for (int l = 0; l < k; ++l) {
                temp += a[i + l * lda] * b[l + j * ldb];
            }
            c[i + j * ldc] = alpha * temp + beta * c[i + j * ldc];
        }
    }
}

--------------- Code Block 3 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    int i, j, l;
    double temp;

    #pragma acc parallel loop collapse(2) private(i, j, l, temp)
    for (j = 0; j < n; ++j) {
        for (i = 0; i < m; ++i) {
            temp = 0.0;
            for (l = 0; l < k; ++l) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }
}

--------------- Code Block 4 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, 
                   double *b, int ldb, double beta, double *c, int ldc) {
    int i, j, l;
    double temp;

    #pragma acc parallel loop gang collapse(2) private(i, j, l, temp) present(a[0:lda*k], b[0:ldb*n], c[0:ldc*n])
    for (j = 0; j < n; j++) {
        for (i = 0; i < m; i++) {
            temp = 0.0;

            #pragma acc loop worker reduction(+:temp)
            for (l = 0; l < k; l++) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }

            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }
}

--------------- Code Block 5 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double* a, int lda, double* b, int ldb, double beta, double* c, int ldc) {
    int i, j, l;
    double temp;

    // OpenACC directive for parallelization
    #pragma acc parallel loop collapse(2) private(i, j, l, temp)
    for (j = 0; j < n; j++) {
        for (i = 0; i < m; i++) {
            temp = 0.0;
            for (l = 0; l < k; l++) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }
}

--------------- Code Block 6 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i, j, l;

    #pragma acc parallel loop collapse(2) private(i, j, l) present(a[0:lda*k], b[0:ldb*n], c[0:ldc*n])
    for (j = 0; j < n; ++j) {
        for (i = 0; i < m; ++i) {
            double temp = 0.0;
            for (l = 0; l < k; ++l) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }
}

--------------- Code Block 7 ---------------
void gemm_parallel(size_t m, size_t n, size_t k, double alpha, double* a, size_t lda, double* b, size_t ldb, double beta, double* c, size_t ldc) {
    size_t i, j, l;
    double temp;

    // OpenACC parallel directive with loop gang(worker vector) construct for parallelism
    #pragma acc parallel loop collapse(2) \
        private(i, j, l, temp) \
        present(a[0:lda*k], b[0:ldb*n], c[0:ldc*n])
    for (j = 0; j < n; j++) {  
        for (i = 0; i < m; i++) {
            temp = 0.0;
            for (l = 0; l < k; l++) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }
}

--------------- Code Block 8 ---------------
void gemm_parallel(int m, int n, int k, double alpha, double *a, int lda, double *b, int ldb, double beta, double *c, int ldc) {
    int i, j, l;
    double temp;

    #pragma acc parallel loop private(i, j, l, temp) present(a[0:lda*k], b[0:ldb*n], c[0:ldc*n])
    for (j = 0; j < n; j++) {
        for (i = 0; i < m; i++) {
            temp = 0.0;
            for (l = 0; l < k; l++) {
                temp += a[i * lda + l] * b[l * ldb + j];
            }
            c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
        }
    }
}

--------------- Code Block 9 ---------------
void gemm_parallel(size_t m, size_t n, size_t k, double alpha, const double *a, size_t lda, const double *b, size_t ldb, double beta, double *c, size_t ldc) {
    size_t i, j, l;
    double temp;

    #pragma acc data copyin(a[0:lda * k], b[0:ldb * n]), copy(c[0:ldc * n])
    {
        #pragma acc parallel loop private(i, j, l, temp)
        for (j = 0; j < n; ++j) {
            for (i = 0; i < m; ++i) {
                temp = 0.0;
                for (l = 0; l < k; ++l) {
                    temp += a[i + l * lda] * b[l + j * ldb];
                }
                c[i + j * ldc] = alpha * temp + beta * c[i + j * ldc];
            }
        }
    }
}

--------------- Code Block 10 ---------------
void gemm_parallel(size_t m, size_t n, size_t k, double alpha,
                   const double *a, size_t lda, const double *b, size_t ldb,
                   double beta, double *c, size_t ldc) {
    size_t i, j, l;
    double temp;

    #pragma acc data copyin(a[0:lda*k], b[0:ldb*n]), copy(c[0:ldc*n])
    {
        #pragma acc parallel loop collapse(2) private(i, j, l, temp)
        for (j = 0; j < n; j++) {
            for (i = 0; i < m; i++) {
                temp = 0.0;
                for (l = 0; l < k; l++) {
                    temp += a[i * lda + l] * b[l * ldb + j];
                }
                c[i * ldc + j] = alpha * temp + beta * c[i * ldc + j];
            }
        }
    }
}

