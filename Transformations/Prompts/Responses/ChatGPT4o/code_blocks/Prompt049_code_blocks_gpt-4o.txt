--------------- Code Block 1 ---------------
void spmv_parallel(int n, int nnz,
                   const Kokkos::View<double*> val,
                   const Kokkos::View<int*> row,
                   const Kokkos::View<int*> col,
                   const Kokkos::View<double*> x,
                   Kokkos::View<double*> y) {

    using execution_space = Kokkos::DefaultExecutionSpace;
    using range_policy = Kokkos::RangePolicy<execution_space>;

    Kokkos::parallel_for("SparseMatrixVectorMultiply", range_policy(0, n), KOKKOS_LAMBDA(const int i) {
        y(i) = 0.0;
        for (int j = row(i); j < row(i + 1); ++j) {
            y(i) += val(j) * x(col(j));
        }
    });
}

--------------- Code Block 2 ---------------
void spmv_parallel(int n, int nnz, const Kokkos::View<const double*> &val,
                   const Kokkos::View<const int*> &row, const Kokkos::View<const int*> &col,
                   const Kokkos::View<const double*> &x, Kokkos::View<double*> &y)
{
    // Set y to be a Kokkos parallel range
    Kokkos::parallel_for("InitY", n, KOKKOS_LAMBDA(int i) {
        y(i) = 0.0;
    });

    // Perform the SpMV operation using Kokkos parallel for
    Kokkos::parallel_for("SpMV", n, KOKKOS_LAMBDA(int i) {
        for (int j = row(i); j < row(i+1); ++j) {
            y(i) += val(j) * x(col(j));
        }
    });
}

--------------- Code Block 3 ---------------
void spmv_parallel(int n, int nnz, 
                   const Kokkos::View<double*> &val, 
                   const Kokkos::View<int*> &row, 
                   const Kokkos::View<int*> &col, 
                   const Kokkos::View<double*> &x, 
                   Kokkos::View<double*> &y) {
    
    // Ensure the output vector y is initialized to zero
    Kokkos::parallel_for("Initialize_y", Kokkos::RangePolicy<>(0, n), KOKKOS_LAMBDA(int i) {
        y(i) = 0.0;
    });

    // Perform the SpMV operation
    Kokkos::parallel_for("SPMV", Kokkos::RangePolicy<>(0, n), KOKKOS_LAMBDA(int i) {
        for (int j = row(i); j < row(i + 1); ++j) {
            y(i) += val(j) * x(col(j));
        }
    });
}

--------------- Code Block 4 ---------------
void spmv_parallel(int n, int nnz, 
                   Kokkos::View<const double*> val, 
                   Kokkos::View<const int*> row, 
                   Kokkos::View<const int*> col, 
                   Kokkos::View<const double*> x, 
                   Kokkos::View<double*> y) 
{
    // Ensure sizes match the expectations
    if (val.extent(0) != (unsigned)nnz || row.extent(0) != (unsigned)(n + 1) || col.extent(0) != (unsigned)nnz || x.extent(0) != (unsigned)n || y.extent(0) != (unsigned)n) {
        throw std::runtime_error("Input View sizes do not match expected sizes.");
    }

    // Parallel execution policy
    Kokkos::parallel_for("spmv_parallel", n, KOKKOS_LAMBDA(int i) {
        y(i) = 0.0;
        for (int j = row(i); j < row(i + 1); ++j) {
            y(i) += val(j) * x(col(j));
        }
    });
}

--------------- Code Block 5 ---------------
void spmv_parallel(const Ordinal n, const Ordinal nnz,
                   const Scalar* val, const Ordinal* row, const Ordinal* col,
                   const Scalar* x, Scalar* y) {
  // Create Kokkos Views from raw pointers
  Kokkos::View<const Scalar*> d_val(val, nnz);
  Kokkos::View<const Ordinal*> d_row(row, n + 1);
  Kokkos::View<const Ordinal*> d_col(col, nnz);
  Kokkos::View<const Scalar*> d_x(x, n);
  Kokkos::View<Scalar*> d_y(y, n);

  // Parallel for loop over rows
  Kokkos::parallel_for("SpMV", Kokkos::RangePolicy<>(0, n), KOKKOS_LAMBDA(const Ordinal i) {
    d_y(i) = 0.0;
    for (Ordinal j = d_row(i); j < d_row(i + 1); ++j) {
      d_y(i) += d_val(j) * d_x(d_col(j));
    }
  });

  // Ensure results are accessible on the host
  Kokkos::fence();
}

--------------- Code Block 6 ---------------
void spmv_parallel(int n, int nnz, const double* val, const int* row, const int* col, const double* x, double* y) {
    // Create Kokkos views from raw pointers
    Kokkos::View<const double*> d_val(val, nnz);
    Kokkos::View<const int*> d_row(row, n + 1);
    Kokkos::View<const int*> d_col(col, nnz);
    Kokkos::View<const double*> d_x(x, n);
    Kokkos::View<double*> d_y(y, n);

    // Initialize y vector to zero
    Kokkos::deep_copy(d_y, 0.0);

    // Parallel for loop using Kokkos
    Kokkos::parallel_for("spmv_parallel", Kokkos::RangePolicy<>(0, n), KOKKOS_LAMBDA(int i) {
        double sum = 0.0;
        for (int j = d_row(i); j < d_row(i + 1); ++j) {
            sum += d_val(j) * d_x(d_col(j));
        }
        d_y(i) = sum;
    });

    // Copy result back to host
    Kokkos::deep_copy(Kokkos::View<double*, Kokkos::HostSpace>(y, n), d_y);
}

--------------- Code Block 7 ---------------
--------------- Code Block 8 ---------------
void spmv_parallel(const int n, const int nnz,
                   const UnmanagedConstVectorType& val, 
                   const UnmanagedConstIndexType& row,
                   const UnmanagedConstIndexType& col,
                   const UnmanagedConstVectorType& x,
                   VectorType& y)
{
    Kokkos::parallel_for("SpMV", Kokkos::RangePolicy<>(0, n), KOKKOS_LAMBDA(const int i) {
        double sum = 0.0;
        for (int j = row(i); j < row(i+1); ++j) {
            sum += val(j) * x(col(j));
        }
        y(i) = sum;
    });
}

--------------- Code Block 9 ---------------
void spmv_parallel(int n, int nnz, const std::vector<double>& val, const std::vector<int>& row, const std::vector<int>& col, const std::vector<double>& x, std::vector<double>& y) {
  // Wrap raw pointers from std::vector to Kokkos views
  Kokkos::View<const double*, Kokkos::HostSpace> val_view(val.data(), nnz);
  Kokkos::View<const int*, Kokkos::HostSpace> row_view(row.data(), n + 1);
  Kokkos::View<const int*, Kokkos::HostSpace> col_view(col.data(), nnz);
  Kokkos::View<const double*, Kokkos::HostSpace> x_view(x.data(), n);
  Kokkos::View<double*, Kokkos::HostSpace> y_view(y.data(), n);
  
  // Parallel for loop using Kokkos
  Kokkos::parallel_for("spmv_parallel", n, KOKKOS_LAMBDA(int i) {
    y_view(i) = 0.0;
    for (int j = row_view(i); j < row_view(i+1); ++j) {
      y_view(i) += val_view(j) * x_view(col_view(j));
    }
  });

  // Ensure that all operations are complete before returning
  Kokkos::fence();
}

--------------- Code Block 10 ---------------
void spmv_parallel(int n, int nnz, const double* val, const int* row, const int* col, const double* x, double* y) {
  // Convert raw pointers to Kokkos views
  Kokkos::View<const double*> d_val(val, nnz);
  Kokkos::View<const int*> d_row(row, n + 1);
  Kokkos::View<const int*> d_col(col, nnz);
  Kokkos::View<const double*> d_x(x, n);
  Kokkos::View<double*> d_y(y, n);

  // Initialize the output vector y
  Kokkos::parallel_for("InitializeY", n, KOKKOS_LAMBDA(int i) {
    d_y(i) = 0.0;
  });

  // Perform SpMV
  Kokkos::parallel_for("SpMV", n, KOKKOS_LAMBDA(int i) {
    for(int j = d_row(i); j < d_row(i + 1); ++j) {
      d_y(i) += d_val(j) * d_x(d_col(j));
    }
  });
}

